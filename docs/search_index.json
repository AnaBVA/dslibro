[
["index.html", "Introducción a la Ciencia de Datos Análisis de Datos y Algoritmos de Predicción con R Prefacio", " Introducción a la Ciencia de Datos Análisis de Datos y Algoritmos de Predicción con R Rafael A. Irizarry 2020-03-04 Prefacio Este libro comenzó como las notas utilizadas para enseñar la clase de HarvardX [Data Science Series] (https://www.edx.org/professional-certificate/harvardx-data-science)1. El código de [Fix:] rebaja R utilizado para generar el libro está disponible en [GitHub] (https://github.com/rafalab/dsbook)2. Tengan en cuenta que el tema gráfico utilizado para [Fix:] las tramas a lo largo del libro se puede recrear utilizando el ds_theme_set() función del paquete dslabs. Una versión en PDF de este libro está disponible en [Leanpub] (https://leanpub.com/datasciencebook)3. Una copia impresa está disponible en [CRC Press] (https://www.crcpress.com/Introduction-to-Data-Science-Data-Analysis-and-Prediction-Algorithms-with/Irizarry/p/book/9780367357986)4. Este trabajo se publica bajo la licencia Creative Commons Reconocimiento-NoComercial-CompartirIgual 4.0 Internacional [CC BY-NC-SA 4.0] (https://creativecommons.org/licenses/by-nc-sa/4.0). Hacemos anuncios relacionados al libro en Twitter. Para la información más reciente, siga [@rafalab] (https://twitter.com/rafalab). https://www.edx.org/professional-certificate/harvardx-data-science↩ https://github.com/rafalab/dsbook↩ https://leanpub.com/datasciencebook↩ https://www.crcpress.com/Introduction-to-Data-Science-Data-Analysis-and-Prediction-Algorithms-with/Irizarry/p/book/9780367357986↩ "],
["agradecimientos.html", "Agradecimientos", " Agradecimientos Este libro está dedicado a todas las personas involucradas en la construcción y el mantenimiento de R y los paquetes R que utilizamos en el libro. Un agradecimiento especial a los desarrolladores y mantenedores de R base, tidyverse y el paquete caret. Un agradecimiento especial a mi tidyverse gurú David Robinson y Amy Gill por docenas de comentarios, ediciones y sugerencias. Además, muchas gracias a Stephanie Hicks, que sirvió dos veces como co-instructora en mis clases de ciencias de datos y a Yihui Xie, que pacientemente soportó mis muchas preguntas sobre la reserva. Gracias también a Karl Broman, de quien tomé prestadas ideas para las piezas de herramientas de visualización y productividad de datos, y a Hector Corrada-Bravo, por sus consejos sobre cómo mejor enseñar [FIX:] machine learning. Gracias a Peter Aldhous, de quien tomé prestadas ideas para los principios de la sección de visualización de datos y a Jenny Bryan por escribir Happy Git y GitHub para useR, que influyeron en nuestros capítulos de Git. Gracias a Alyssa Frazee por ayudar a crear el problema de tarea que se convirtió en el capítulo de Sistemas de Recomendación y a Amanda Cox por proporcionar los datos de los exámenes de los Regentes de Nueva York. Además, muchas gracias a Jeff Leek, Roger Peng y Brian Caffo, cuya clase inspiró la forma en que se divide este libro y a Garrett Grolemund y Hadley Wickham por abrir el código de reserva para su libro R for Data Science. Finalmente, gracias a Alex Nones por corregir el manuscrito durante sus diversas etapas. Este libro fue concebido durante la enseñanza de varios cursos de estadística aplicada, comenzando hace más de quince años. Los profesores asistentes que trabajaron conmigo a lo largo de los años hicieron importantes contribuciones indirectas a este libro. La última versión de este curso es una serie de HarvardX coordinada por Heather Sternshein y Zofia Gajdos. Les agradecemos por sus contribuciones. También estamos agradecidos a todos los estudiantes cuyas preguntas y comentarios nos ayudaron a mejorar el libro. Los cursos fueron parcialmente financiados por la beca NIH R25GM114818. Agradecemos los Institutos Nacionales de Salud por su apoyo. Un agradecimiento especial a todos aquellos que editaron el libro a través de solicitudes de extracción de GitHub o hicieron sugerencias creando un ejemplo o enviando un correo electrónico: nickyfoto (Huang Qiang) desautm (Marc-André Désautels), michaschwab (Michail Schwab) alvarolarreategui (Alvaro Larreategui), jakevc (Jake VanCampen), omerta (Guillermo Lengemann), espinielli (Enrico Spinielli), asimumba(Aaron Simumba) braunschweig (Maldewar), gwierzchowski (Grzegorz Wierzchowski), technocrat (Richard Careaga) atzakas, defeit (David Emerson Feit), shiraamitchell (Shira Mitchell) Nathalie-S, andreashandel (Andreas Handel) berkowitze (Elias Berkowitz) Dean-Webb (Dean Webber), mohayusuf, jimrothstein, mPloenzke (Matthew Ploenzke), NicholasDowand (Nicholas Dow) kant (Darío Hereñú), debbieyuster (Debbie Yuster), tuanchauict (Tuan Chau), phzeller, David D. Kane, El Mustapha El Abbassi y Vadim Zipunnikov. "],
["introduccion.html", "Introducción Case studies ¿Quién encontrará útil este libro? 0.1 ¿Que cubre este libro? {-}f ¿Qué no cubre este libro?", " Introducción La demanda de profesionales cualificados en ciencias de datos en la industria la academia y el gobierno está creciendo rápidamente. Este libro presenta conceptos y destrezas que pueden ayudarlos a enfrentar los desafíos del análisis de datos en situaciones reales. El texto abarca los conceptos de probabilidad, inferencia estadística, regresión lineal y [FIX:] machine learning. También les ayudará a desarrollar destrezas como la programación en R, [FIX:] data wrangling dplyr, visualización de datos con ggplot2, creación de algoritmos con caret, organización de archivos con UNIX/ Linux shell, control de versiones con Git y GitHub y preparación de documentos reproducibles con knitr y R markdown . El libro se divide en seis partes: R, Visualización de datos, [Fix:] Data Wrangling, Estadísticas con R, Machine Learning y Herramientas de productividad. Cada parte tiene varios capítulos que se deben presentar como una sola conferencia e incluye docenas de ejercicios distribuidos a través de los capítulos. Case studies A lo largo del libro, utilizamos [Fix:] motivating case studies. En cada [Fix:] case study, intentamos imitar de manera realista la experiencia de los científicos de datos. Para cada uno de los conceptos que discutimos, comenzamos haciendo preguntas específicas a las que entonces respondemos mediante un análisis de datos. Aprendemos los conceptos como un medio para responder a las preguntas. Ejemplos de los [Fix:] w case studies incluidos en el libro son: [Fix:] Case Study Concepto Tasas de asesinatos en Estados Unidos por estado R Conceptos básicos Alturas de estudiantes Resúmenes estadísticos Tendencias en la salud y la economía mundial Visualización de datos El impacto de las vacunas en las tasas de enfermedades infecciosas Visualización de datos La crisis financiera de 2007-2008 Probabilidad Previsión de elecciones Inferencia estadística Alturas [Fix:] reported de estudiantes Data wrangling Money Ball: Construyendo un equipo de béisbol Regresión lineal MNIST: Procesamiento de imagen de dígitos escritos a mano [Fix:] Machine Learning Sistemas de recomendación de películas [Fix:] Machine Learning ¿Quién encontrará útil este libro? El próposito de este libro es servir como un texto para un primer curso de ciencia de datos. No es necesario tener conocimientos previos de R, aunque algo de experiencia en la programación puede ser útil. Los conceptos estadísticos utilizados para responder a las preguntas de [FIX:] case studies se presentan sólo brevemente, y por tanto recomendamos un libro de texto de Probabilidad y Estadística para los que quieran entender a fondo estos conceptos. Al leer y comprender todos los capítulos y completar todos los ejercicios, los estudiantes estarán bien posicionados para realizar tareas básicas de análisis de datos y aprender los conceptos y las destrezas más avanzadas que son necesarios para convertirse en un experto. 0.1 ¿Que cubre este libro? {-}f Comenzamos repasando los conceptos básicos de R y el tidyverse. Aprenderán R a lo largo del libro, pero en la primera parte nos dedicamos a revisar los componentes básicos necesarios para seguir aprendiendo. La creciente disponibilidad de conjuntos de datos informativos y herramientas de [Fix:] software ha llevado a una mayor dependencia de la visualizaciones de datos en muchos campos. En la segunda parte, demostramos cómo usar ggplot2 para generar gráficos y describir principios importantes de visualización de datos. En la tercera parte demostramos la importancia de las estadísticas en el análisis de datos respondiendo a preguntas de [[FIX:] case studies usando ** probabilidad, inferencia y regresión ** con R. La cuarta parte utiliza varios ejemplos para familiarizar a los lectores con data wrangling. Entre las destrezas específicas que estudiamos están el [FIX:] web scraping, el uso de expresiones regulares y la unión y remodelación de tablas de datos. Hacemos esto usando las herramientas de tidyverse. En la quinta parte presentamos varios desafíos que nos llevan a introducir machine learning. Aprendemos a usar [Fix:] el paquete caret para construir algoritmos de predicción que incluyen [FIX:] K-nearest neighbors and random forests. En la parte final, proporcionamos una breve introducción a las herramientas de productividad que usamos diariamente en proyectos de ciencia de datos. Estos son RStudio, UNIX/ Linux shell, Git y GitHub, y knitr y R Markdown. ¿Qué no cubre este libro? Este libro se enfoca en los aspectos de análisis de datos de la ciencia de datos. Por consiguiente, no discutimos aspectos relacionados con la gestión de datos o la ingeniería. Aunque la programación en R es una parte esencial del libro, no enseñamos temas informáticos más avanzados como las structuras de datos, la optimización y la teoría de algoritmos. Del mismo modo, no discutimos temas como los servicios web, gráficos interactivos, computación paralela y [FIX:] data streaming processing. Los conceptos estadísticos se presentan principalmente como herramientas para resolver problemas y no se incluyen descripciones teóricas en profundidad en este libro. "],
["getting-started.html", "Capítulo 1 Comenzando con R y RStudio 1.1 ¿Por qué R? 1.2 La consola R 1.3 [Fix:] Scripts 1.4 RStudio 1.5 Instalación de paquetes R", " Capítulo 1 Comenzando con R y RStudio Sys.getlocale() #&gt; [1] &quot;es_ES.UTF-8/es_ES.UTF-8/es_ES.UTF-8/C/es_ES.UTF-8/en_US.UTF-8&quot; Sys.getenv()[&quot;LANG&quot;] #&gt; LANG es 1:3 + 1:4 #&gt; Warning in 1:3 + 1:4: longitud de objeto mayor no es múltiplo de la #&gt; longitud de uno menor #&gt; [1] 2 4 6 5 1.1 ¿Por qué R? R no es un lenguaje de programación como C o Java. No fue creado por ingenieros de [Fix:] software para el desarrollo de software. En cambio, fue desarrollado por estadísticos como un entorno interactivo para el análisis de datos. Puede leer la historia completa en el artículo Una breve historia de S5. La interactividad es una característica indispensable en la ciencia de datos porque, como pronto aprenderá, la capacidad de explorar rápidamente los datos es necesario para el éxito en este campo. Sin embargo, igual que en otros lenguajes de programación, puede guardar su trabajo como [Fix:] scripts que se pueden ejecutar fácilmente en cualquier momento. Estos [Fix:] scripts sirven como un registro del análisis que realizó, una característica clave que facilita el trabajo reproducible. Programadores expertos no debe esperar que R siga las convenciones a las que están acostumbrados, ya que se sentirán decepcionado. Si es paciente, apreciará el poder desigual de R cuando se trata de análisis de datos y, específicamente, de visualización de datos. Otras características atractivas de R son: R es gratuito y de código abierto6. Se ejecuta en todas las plataformas principales: Windows, Mac Os, UNIX/ Linux. [FIX:] scripts y los objetos de datos se pueden compartir sin problemas entre plataformas. Existe una comunidad grande, creciente y activa de usuarios de R y, como resultado, hay numerosos recursos para aprender y hacer preguntas[https://stats.stackexchange.com/questions/138/free-resources- for-learning-r][https://www.r-project.org/help.html]7. Es fácil para otras personas contribuir con [FIX:] add-ons que permiten a los desarrolladores compartir implementaciones de [FIX:] software de nuevas metodologías de ciencia de datos. Esto les da a los usuarios de R acceso temprano a los últimos métodos y herramientas que se desarrollan para una amplia variedad de disciplinas, incluyendo la ecología, biología molecular, ciencias sociales y geografía, entre otros campos. 1.2 La consola R El análisis de datos interactivo generalmente ocurre en la R consola que ejecuta [FIX:] commands a medida que los escribe. Hay varias formas de obtener acceso a una consola R. Una forma es simplemente iniciar R en su computadora. La consola se parece a esto: Como ejemplo rápido, intente usar la consola para calcular una propina del 15% en una comida que cuesta $ 19.71: 0.15 * 19.71 #&gt; [1] 2.96 ** Tenga en cuenta que en este libro, los cuadros grises se utilizan para mostrar el código R escrito en la consola R. El símbolo #&gt; se usa para denotar lo que produce la consola R. ** 1.3 [Fix:] Scripts Una de las grandes ventajas de R sobre [FIX:] point-and-clic analysis software es que puede guardar su trabajo como [FIX:] scripts. Puede editar y guardar estos scripts con un editor de texto. El material de este libro se desarrolló utilizando el _tiempo de desarrollo integrado interactivo (IDE) RStudio8. RStudio incluye un editor con muchas características específicas de R, una consola para ejecutar su código y otros paneles útiles, incluso uno para mostrar figuras. La mayoría de [FIX:] web-based consolas de R también proporcionan un panel para editar scripts, pero no todos le permiten guardar los scripts para su uso posterior. Todos los scripts de R utilizados para generar este libro se pueden encontrar en GitHub9. 1.4 RStudio RStudio será nuestra plataforma de lanzamiento para proyectos de ciencia de datos. No sólo nos proporciona un editor para crear y editar nuestros scripts, sino que también proporciona muchas otras herramientas útiles. En esta sección, repasaremos algunos de los conceptos básicos. 1.4.1 [FIX:] The panes Cuando inicie RStudio por primera vez, verá tres paneles. El panel izquierdo muestra la consola R. A la derecha, el panel superior incluye pestañas como Environment_y_History, mientras que el panel inferior muestra cinco [FIX:] tabs: File, Plots, Packages, Help_y_Viewer (estas pestañas pueden cambiar en las nuevas versiones). Puede hacer clic en cada pestaña para moverse por las diferentes [FIX:] features (funciones?). Para iniciar una nueva secuencia de [FIX:] commands, puede hacer clic en [FIX:] Archivo, Nuevo archivo, luego en R Script (No creo que estos se deben traducir). Esto inicia un nuevo panel a la izquierda y es aquí donde puede comenzar a escribir su secuencia de [FIX:] commands. 1.4.2 [FIX:] Key Bindings: Atajos de teclado Muchas de las tareas que realizamos con el mouse se pueden lograr con una combinación de pulsaciones de teclado. Estas versiones de teclado para realizar tareas se denominan [FIX:] claves de teclas. Por ejemplo, acabamos de mostrar cómo usar el mouse para iniciar un nuevo script, pero también se puede usar una combinación de teclas: Ctrl + Shift + N en Windows y command + shift + N en Mac. Aunque en este tutorial a menudo mostramos cómo usar el mouse, recomendamos que memorice las combinaciones de teclas para las operaciones que usa más. RStudio proporciona una hoja de referencia útil con los comandos más utilizados. Puede obtenerlo directamente de RStudio: Recomendamos tener esto a mano para poder buscar las combinaciones de teclas cuando se encuentre realizando [FIX:] point-and-click repetitivos. 1.4.3 Ejecutando comandos mientras edita scripts Hay muchos editores diseñados específicamente para la codificación. Estos son útiles porque el color y [FIX:] la sangría (note-sangria is apparently correct) se agregan automáticamente para que el código sea más legible. RStudio es uno de estos editores, y fue desarrollado específicamente para R. Una de las principales ventajas proporcionadas por RStudio sobre otros editores es que podemos probar nuestro código fácilmente mientras editamos nuestros scripts. A continuación mostramos un ejemplo. Comencemos abriendo un nuevo script como lo hicimos antes. El siguiente paso es darle un nombre al script. Podemos hacer esto a través del editor guardando [FIX:] el nuevo script actual sin nombre. Para hacer esto, haga clic en el icono de guardar o use la combinación de teclas Ctrl + S en Windows y comando + S en la Mac. Cuando solicite que se guarde el documento por primera vez, RStudio le pedirá un nombre. Una buena convención es usar un nombre descriptivo, con letras minúsculas, sin espacios, sólo guiones para separar las palabras, y luego seguido del sufijo .R. Llamaremos a este script my-first-script.R. Ahora estamos listos para comenzar a editar nuestro primer script. Las primeras líneas de código en un script de R están dedicadas a cargar las bibliotecas que usaremos. Otra característica útil de RStudio es que una vez escribimos library() comienza a completarse automáticamente con las bibliotecas que hemos instalado. Tenga en cuenta lo que sucede cuando escribimos library(ti): Otra característica que puede haber notado es que cuando escribe library( el segundo paréntesis se agrega automáticamente. Esto lo ayudará a evitar uno de los errores más comunes en la codificación: olvidar cerrar un paréntesis. Ahora podemos continuar escribiendo código. Como ejemplo, haremos un gráfico que muestre los totales de asesinatos versus los totales de población por estado. Una vez que haya terminado de escribir el código necesario para hacer este diagrama, puede probarlo [FIX:] (quieres traducir este comando? se dice código para code?) ejecutando el código. Para hacer esto, haga clic en el botón Run en la parte derecha superior del [FIX:] editing pane. También puede usar la combinación de teclas: Ctrl + Shift + Enter en Windows o command + shift + return en Mac. Una vez que ejecute [FIX:] el code, verá que aparece en la consola R y, en este caso, la gráfica generada aparece en la consola de gráficas. Tenga en cuenta que la consola de gráficos tiene una interfaz útil que le permite hacer clic hacia atrás y adelante en diferentes gráficos, hacer zoom en el gráfico o guardar los gráficos como archivos. Para ejecutar una línea a la vez en lugar del script completo, puede usar Control-Enter en Windows y [FIX:] (debemos traducir esto?) comando-retorno en Mac. 1.4.4 Cambio de opciones globales Puede cambiar el aspecto y la funcionalidad de RStudio bastante. Para cambiar las opciones globales, haga clic en [FIX:] (debemos traducir esto?) Herramientas_y luego en_Opciones globales …. Como ejemplo, mostramos cómo hacer un cambio que recomendamos. Esto es para [FIX:] (no creo que debemos traducir) cambiar el Guardar espacio de trabajo a .RData en la salida_a_Nunca_y desmarcar_Restore .RData en el espacio de trabajo al inicio. De manera predeterminada, cuando uno sale de R, el programa guarda todos los objetos que ha creado en un archivo llamado .RData. Esto se hace para que cuando reinicie la sesión en la misma carpeta, cargue estos objetos. Encontramos que esto causa confusión, especialmente cuando compartimos código con colegas y asumimos que tienen este archivo .RData. Para cambiar estas opciones, haga que su configuración General se vea así: 1.5 Instalación de paquetes R La funcionalidad proporcionada por una nueva instalación de R es sólo una pequeña fracción de lo que es posible. De hecho, nos referimos a lo que obtiene después de su primera instalación como base R. La funcionalidad adicional proviene de complementos disponibles de los desarrolladores. Actualmente hay cientos de estos disponibles de CRAN y muchos otros compartidos a través de otros repositorios como GitHub. Sin embargo, debido a que no todo el mundo necesita todas las funciones disponibles, R pone a disposición diferentes componentes a través de [FIX:] (creo que no debemos traducir esto) paquetes. R facilita la instalación de paquetes desde R. Por ejemplo, para instalar el paquete dslabs, que usamos para compartir conjuntos de datos y códigos relacionados con este libro, debe escribir: install.packages(&quot;dslabs&quot;) En RStudio, puede navegar a la [FIX:] pestaña Herramientas y seleccionar [FIX:] (creo que no debemos traducir esto) instalar paquetes. Luego podemos cargar el paquete en nuestras sesiones R usando la función library: library(dslabs) A medida que vaya leyendo este libro, verá que cargamos paquetes sin instalarlos. Esto se debe a que una vez que instale un paquete, permanece instalado y sólo necesita cargarse con library. El paquete permanece cargado hasta que salgamos de la sesión R. Si intenta cargar un paquete y obtiene un error, probablemente significa que necesita instalarlo primero. Podemos instalar más de un paquete a la vez [FIX:] (by feeding a character vector to this function) alimentando un vector de caracteres a esta función: install.packages(c(&quot;tidyverse&quot;, &quot;dslabs&quot;)) Tenga en cuenta que la instalación de tidyverse en realidad instala varios paquetes. Esto ocurre comúnmente cuando un paquete tiene * dependencias * o usa funciones de otros paquetes. Cuando carga un paquete usando library, también carga sus dependencias. Una vez que los paquetes están instalados, puede cargarlos en R y no necesita instalarlos nuevamente, a menos que instale una versión nueva de R. Recuerde que los paquetes están instalados en R y no en RStudio. Es útil mantener una lista de todos los paquetes que necesita para su trabajo en un script porque si tiene que realizar una instalación nueva de R, puede reinstalar todos sus paquetes simplemente ejecutando un script. Puede ver todos los paquetes que ha instalado utilizando la siguiente función: installed.packages() https://pdfs.semanticscholar.org/9b48/46f192aa37ca122cfabb1ed1b59866d8bfda.pdf↩ https://opensource.org/history↩ https://stackoverflow.com/documentation/r/topics↩ https://www.rstudio.com/↩ https://github.com/rafalab/dsbook↩ "],
["r-basics.html", "Capítulo 2 R básicos 2.1 Estudio de caso: asesinatos de armas 2.2 Los muy básicos 2.3 Ejercicios 2.4 Tipos de datos 2.5 Ejercicios 2.6 Vectores 2.7 Coerción 2.8 Ejercicios 2.9 Ejercicios 2.10 Aritmética de vectores 2.11 Ejercicios 2.12 Indexación 2.13 Ejercicios 2.14 Parcelas básicas 2.15 Ejercicios", " Capítulo 2 R básicos En este libro, utilizaremos el entorno de software R para todos nuestros análisis. Aprenderá R y técnicas de análisis de datos simultáneamente. Para seguir, por lo tanto, necesitará acceso a R. También recomendamos el uso de un entorno de desarrollo integrado (IDE), como RStudio, para guardar su trabajo. Tenga en cuenta que es común que un curso o taller ofrezca acceso a un entorno R y un IDE a través de su navegador web, como lo hace RStudio cloud10. Si tiene acceso a dicho recurso, no necesita instalar R y RStudio. Sin embargo, si tiene la intención de convertirse en un analista de datos avanzado, recomendamos instalar estas herramientas en su computadora11. Tanto R como RStudio son gratuitos y están disponibles en línea. 2.1 Estudio de caso: asesinatos de armas Imagine que vive en Europa y se le ofrece un trabajo en una empresa estadounidense con muchas ubicaciones en todos los estados. Es un gran trabajo, pero noticias con titulares como ** Tasa de homicidios con armas de fuego de EE. UU. Más alta que otros países desarrollados **12 ¿te preocupa? Gráficos como este pueden preocuparte aún más: Pero entonces recuerdas que Estados Unidos es un país grande y diverso con 50 estados muy diferentes, así como el Distrito de Columbia (DC). California, por ejemplo, tiene una población más grande que Canadá, y 20 estados de EE. UU. Tienen poblaciones más grandes que la de Noruega. En algunos aspectos, la variabilidad entre los estados de los EE. UU. Es similar a la variabilidad entre los países de Europa. Además, aunque no se incluye en los cuadros anteriores, las tasas de asesinatos en Lituania, Ucrania y Rusia son superiores a 4 por cada 100.000. Entonces, tal vez las noticias informan que te preocupa que seas demasiado superficial. Tiene opciones de dónde vivir y desea determinar la seguridad de cada estado en particular. Obtendremos algunas ideas al examinar datos relacionados con homicidios con armas de fuego en los EE. UU. Durante 2010 usando R. Antes de comenzar con nuestro ejemplo, necesitamos cubrir la logística, así como algunos de los componentes básicos que se requieren para obtener habilidades de R más avanzadas. Tenga en cuenta que la utilidad de algunos de estos bloques de construcción puede no ser obvia de inmediato, pero más adelante en el libro apreciará haber dominado estas habilidades. 2.2 Los muy básicos Antes de comenzar con el motivador conjunto de datos, necesitamos cubrir los conceptos básicos de R. 2.2.1 Objetos Supongamos que un estudiante de secundaria nos pide ayuda para resolver varias ecuaciones cuadráticas de la forma \\(ax^2+bx+c = 0\\). La fórmula cuadrática nos da las soluciones: \\[ \\frac{-b - \\sqrt{b^2 - 4ac}}{2a}\\,\\, \\mbox{ and } \\frac{-b + \\sqrt{b^2 - 4ac}}{2a} \\] que por supuesto cambian dependiendo de los valores de \\(a\\), \\(b\\) y \\(c\\). Una ventaja de los lenguajes de programación es que podemos definir variables y escribir expresiones con estas variables, de forma similar a como lo hacemos en matemáticas, pero obtener una solución numérica. Escribiremos un código general para la ecuación cuadrática a continuación, pero si se nos pide resolver \\(x^2 + x -1 = 0\\), luego definimos: a &lt;- 1 b &lt;- 1 c &lt;- -1 que almacena los valores para su uso posterior. Usamos &lt;- para asignar valores a las variables. También podemos asignar valores usando = en lugar de &lt;-, pero recomendamos no usar = para evitar confusión. Copie y pegue el código anterior en su consola para definir las tres variables. Tenga en cuenta que R no imprime nada cuando hacemos esta asignación. Esto significa que los objetos se definieron con éxito. Si hubiera cometido un error, habría recibido un mensaje de error. Para ver el valor almacenado en una variable, simplemente le pedimos a R que evalúe a y muestra el valor almacenado: a #&gt; [1] 1 Una forma más explícita de pedirle a R que nos muestre el valor almacenado en a esta usando print me gusta esto: print(a) #&gt; [1] 1 Usamos el término objeto para describir cosas que están almacenadas en R. Las variables son ejemplos, pero los objetos también pueden ser entidades más complicadas como funciones, que se describen más adelante. 2.2.2 El espacio de trabajo A medida que definimos objetos en la consola, en realidad estamos cambiando el workspace. Puede ver todas las variables guardadas en su espacio de trabajo escribiendo: ls() #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;dat&quot; &quot;img_path&quot; &quot;murders&quot; En RStudio, la pestaña Environment muestra los valores: Deberíamos ver a, b y c. Si intenta recuperar el valor de una variable que no está en su espacio de trabajo, recibirá un error. Por ejemplo, si escribe x recibirás el siguiente mensaje: Error: object 'x' not found. Ahora, dado que estos valores se guardan en variables, para obtener una solución a nuestra ecuación, utilizamos la fórmula cuadrática: (-b + sqrt(b^2 - 4*a*c) )/ ( 2*a ) #&gt; [1] 0.618 (-b - sqrt(b^2 - 4*a*c) )/ ( 2*a ) #&gt; [1] -1.62 2.2.3 Funciones Una vez que defina las variables, el proceso de análisis de datos generalmente se puede describir como una serie de funciones aplicadas a los datos. R incluye varias funciones predefinidas y la mayoría de las líneas de análisis que construimos hacen un uso extensivo de ellas. Ya usamos el install.packages, library y ls funciones También usamos la función sqrt para resolver la ecuación cuadrática de arriba. Hay muchas más funciones preconstruidas y aún más se pueden agregar a través de paquetes. Estas funciones no aparecen en el espacio de trabajo porque no las definió, pero están disponibles para su uso inmediato. En general, necesitamos usar paréntesis para evaluar una función. Si escribes ls, la función no se evalúa y en su lugar R le muestra el código que define la función. Si escribes ls() la función se evalúa y, como se ve arriba, vemos objetos en el espacio de trabajo. Diferente a ls, la mayoría de las funciones requieren uno o más argumentos. A continuación se muestra un ejemplo de cómo asignamos un objeto al argumento de la función log. Recuerda que anteriormente definimos a ser 1: log(8) #&gt; [1] 2.08 log(a) #&gt; [1] 0 Puede averiguar qué espera la función y qué hace revisando los manuales muy útiles incluidos en R. Puede obtener ayuda utilizando el help funciona así: help(&quot;log&quot;) Para la mayoría de las funciones, también podemos usar esta abreviatura: ?log La página de ayuda le mostrará qué argumentos espera la función. Por ejemplo, log necesidades x y base correr. Sin embargo, algunos argumentos son obligatorios y otros son opcionales. Puede determinar qué argumentos son opcionales observando en el documento de ayuda que se asigna un valor predeterminado con =. Definir esto es opcional. Por ejemplo, la base de la función log por defecto es base = exp(1) haciendo log el registro natural por defecto. Si desea echar un vistazo rápido a los argumentos sin abrir el sistema de ayuda, puede escribir: args(log) #&gt; function (x, base = exp(1)) #&gt; NULL Puede cambiar los valores predeterminados simplemente asignando otro objeto: log(8, base = 2) #&gt; [1] 3 Tenga en cuenta que no hemos estado especificando el argumento x como tal: log(x = 8, base = 2) #&gt; [1] 3 El código anterior funciona, pero podemos ahorrarnos algo de tipeo: si no se usa un nombre de argumento, R asume que está ingresando argumentos en el orden que se muestra en el archivo de ayuda o por args. Entonces, al no usar los nombres, se supone que los argumentos son x seguido por base: log(8,2) #&gt; [1] 3 Si usa los nombres de los argumentos, podemos incluirlos en el orden que queramos: log(base = 2, x = 8) #&gt; [1] 3 Para especificar argumentos, debemos usar = y no puede usar &lt;-. Hay algunas excepciones a la regla de que las funciones necesitan los paréntesis para ser evaluadas. Entre estos, los más utilizados son los operadores aritméticos y relacionales. Por ejemplo: 2^3 #&gt; [1] 8 Puede ver los operadores aritméticos escribiendo: help(&quot;+&quot;) o ?&quot;+&quot; y los operadores relacionales escribiendo: help(&quot;&gt;&quot;) o ?&quot;&gt;&quot; 2.2.4 Otros objetos preconstruidos Hay varios conjuntos de datos que se incluyen para que los usuarios practiquen y prueben funciones. Puede ver todos los conjuntos de datos disponibles escribiendo: data() Esto le muestra el nombre del objeto para estos conjuntos de datos. Estos conjuntos de datos son objetos que se pueden usar simplemente escribiendo el nombre. Por ejemplo, si escribe: co2 R le mostrará los datos de concentración de CO2 atmosférico de Mauna Loa. Otros objetos precompilados son cantidades matemáticas, como la constante \\(\\pi\\) y \\(\\infty\\): pi #&gt; [1] 3.14 Inf+1 #&gt; [1] Inf 2.2.5 Nombres de variables Hemos usado las letras a, b y c como nombres de variables, pero los nombres de variables pueden ser casi cualquier cosa. Algunas reglas básicas en R son que los nombres de variables tienen que comenzar con una letra, no pueden contener espacios y no deben ser variables predefinidas en R. Por ejemplo, no nombre una de sus variables install.packages escribiendo algo como install.packages &lt;- 2. Una buena convención a seguir es usar palabras significativas que describan lo que está almacenado, usar solo minúsculas y usar guiones bajos como sustituto de espacios. Para las ecuaciones cuadráticas, podríamos usar algo como esto: solution_1 &lt;- (-b + sqrt(b^2 - 4*a*c))/ (2*a) solution_2 &lt;- (-b - sqrt(b^2 - 4*a*c))/ (2*a) Para obtener más consejos, recomendamos estudiar la guía de estilo de Hadley Wickham13. 2.2.6 Guardar su espacio de trabajo Los valores permanecen en el espacio de trabajo hasta que finalice su sesión o los borre con la función rm. Pero los espacios de trabajo también se pueden guardar para su uso posterior. De hecho, cuando sale de R, el programa le pregunta si desea guardar su espacio de trabajo. Si lo guarda, la próxima vez que inicie R, el programa restaurará el espacio de trabajo. En realidad, recomendamos no guardar el espacio de trabajo de esta manera porque, a medida que comience a trabajar en diferentes proyectos, será más difícil hacer un seguimiento de lo que se guarda. En su lugar, le recomendamos que asigne al espacio de trabajo un nombre específico. Puedes hacer esto usando la función save o save.image. Para cargar, use la función load. Al guardar un espacio de trabajo, recomendamos el sufijo rda o RData. En RStudio, también puede hacerlo navegando a la pestaña Sesión_y eligiendo_Guardar espacio de trabajo como. Luego puede cargarlo usando las opciones Load Workspace en la misma pestaña. Puedes leer las páginas de ayuda en save, save.image y load aprender más. 2.2.7 Scripts motivadores Para resolver otra ecuación como \\(3x^2 + 2x -1\\), podemos copiar y pegar el código anterior y luego redefinir las variables y volver a calcular la solución: a &lt;- 3 b &lt;- 2 c &lt;- -1 (-b + sqrt(b^2 - 4*a*c))/ (2*a) (-b - sqrt(b^2 - 4*a*c))/ (2*a) Al crear y guardar un script con el código anterior, no necesitaríamos volver a escribir todo cada vez y, en cambio, simplemente cambiar los nombres de las variables. Intente escribir la secuencia de comandos anterior en un editor y observe lo fácil que es cambiar las variables y recibir una respuesta. 2.2.8 Comentando tu código Si una línea de código R comienza con el símbolo #, no se evalúa Podemos usar esto para escribir recordatorios de por qué escribimos un código particular. Por ejemplo, en el script anterior, podríamos agregar: ## Code to compute solution to quadratic equation of the form ax^2 + bx + c ## define the variables a &lt;- 3 b &lt;- 2 c &lt;- -1 ## now compute the solution (-b + sqrt(b^2 - 4*a*c))/ (2*a) (-b - sqrt(b^2 - 4*a*c))/ (2*a) 2.3 Ejercicios 1. ¿Cuál es la suma de los primeros 100 enteros positivos? La fórmula para la suma de enteros. \\(1\\) mediante \\(n\\) es \\(n(n+1)/2\\). Definir \\(n=100\\) y luego usa R para calcular la suma de \\(1\\) mediante \\(100\\) usando la fórmula ¿Cuál es la suma? 2. Ahora use la misma fórmula para calcular la suma de los enteros del 1 al 1,000. 3. Mira el resultado de escribir el siguiente código en R: n &lt;- 1000 x &lt;- seq(1, n) sum(x) En función del resultado, ¿cuáles crees que son las funciones? seq y sum ¿hacer? Puedes usar help. sum crea una lista de números y seq los suma si. seq crea una lista de números y sum los suma seq crea una lista aleatoria y sum calcula la suma de 1 a 1,000. re. sum siempre devuelve el mismo número. 4. En matemáticas y programación, decimos que evaluamos una función cuando reemplazamos el argumento con un número dado. Entonces si escribimos sqrt(4), evaluamos el sqrt función. En R, puede evaluar una función dentro de otra función. Las evaluaciones suceden de adentro hacia afuera. Use una línea de código para calcular el registro, en base 10, de la raíz cuadrada de 100. 5. ¿Cuál de los siguientes siempre devolverá el valor numérico almacenado en x? Puede probar ejemplos y usar el sistema de ayuda si lo desea. log(10^x) si. log10(x^10) log(exp(x)) re. exp(log(x, base = 2)) 2.4 Tipos de datos Las variables en R pueden ser de diferentes tipos. Por ejemplo, necesitamos distinguir números de cadenas de caracteres y tablas de listas simples de números. La función class nos ayuda a determinar qué tipo de objeto tenemos: a &lt;- 2 class(a) #&gt; [1] &quot;numeric&quot; Para trabajar de manera eficiente en R, es importante aprender los diferentes tipos de variables y qué podemos hacer con ellas. 2.4.1 Marcos de datos Hasta ahora, las variables que hemos definido son solo un número. Esto no es muy útil para almacenar datos. La forma más común de almacenar un conjunto de datos en R es en un marco de datos. Conceptualmente, podemos pensar en un marco de datos como una tabla con filas que representan observaciones y las diferentes variables informadas para cada observación que define las columnas. Los marcos de datos son particularmente útiles para conjuntos de datos porque podemos combinar diferentes tipos de datos en un solo objeto. Una gran proporción de los desafíos del análisis de datos comienza con los datos almacenados en un marco de datos. Por ejemplo, almacenamos los datos para nuestro ejemplo motivador en un marco de datos. Puede acceder a este conjunto de datos cargando la biblioteca dslabs y cargando murders conjunto de datos utilizando el data función: library(dslabs) data(murders) Para ver que esto es de hecho un marco de datos, escribimos: class(murders) #&gt; [1] &quot;data.frame&quot; 2.4.2 Examinando un objeto La función str es útil para obtener más información sobre la estructura de un objeto: str(murders) #&gt; &#39;data.frame&#39;: 51 obs. of 5 variables: #&gt; $ state : chr &quot;Alabama&quot; &quot;Alaska&quot; &quot;Arizona&quot; &quot;Arkansas&quot; ... #&gt; $ abb : chr &quot;AL&quot; &quot;AK&quot; &quot;AZ&quot; &quot;AR&quot; ... #&gt; $ region : Factor w/ 4 levels &quot;Northeast&quot;,&quot;South&quot;,..: 2 4 4 2 4 4 1 2 2 #&gt; 2 ... #&gt; $ population: num 4779736 710231 6392017 2915918 37253956 ... #&gt; $ total : num 135 19 232 93 1257 ... Esto nos dice mucho más sobre el objeto. Vemos que la tabla tiene 51 filas (50 estados más DC) y cinco variables. Podemos mostrar las primeras seis líneas usando la función head: head(murders) #&gt; state abb region population total #&gt; 1 Alabama AL South 4779736 135 #&gt; 2 Alaska AK West 710231 19 #&gt; 3 Arizona AZ West 6392017 232 #&gt; 4 Arkansas AR South 2915918 93 #&gt; 5 California CA West 37253956 1257 #&gt; 6 Colorado CO West 5029196 65 En este conjunto de datos, cada estado se considera una observación y se informan cinco variables para cada estado. Antes de continuar con la respuesta a nuestra pregunta original sobre los diferentes estados, aprendamos más sobre los componentes de este objeto. 2.4.3 El descriptor de acceso: $ Para nuestro análisis, necesitaremos acceder a las diferentes variables representadas por columnas incluidas en este marco de datos. Para hacer esto, utilizamos el operador de acceso $ de la siguiente manera: murders$population #&gt; [1] 4779736 710231 6392017 2915918 37253956 5029196 3574097 #&gt; [8] 897934 601723 19687653 9920000 1360301 1567582 12830632 #&gt; [15] 6483802 3046355 2853118 4339367 4533372 1328361 5773552 #&gt; [22] 6547629 9883640 5303925 2967297 5988927 989415 1826341 #&gt; [29] 2700551 1316470 8791894 2059179 19378102 9535483 672591 #&gt; [36] 11536504 3751351 3831074 12702379 1052567 4625364 814180 #&gt; [43] 6346105 25145561 2763885 625741 8001024 6724540 1852994 #&gt; [50] 5686986 563626 ¿Pero cómo supimos usar population? Anteriormente, aplicando la función str al objeto murders, revelamos los nombres de cada una de las cinco variables almacenadas en esta tabla. Podemos acceder rápidamente a los nombres de las variables usando: names(murders) #&gt; [1] &quot;state&quot; &quot;abb&quot; &quot;region&quot; &quot;population&quot; &quot;total&quot; Es importante saber que el orden de las entradas en murders$population conserva el orden de las filas en nuestra tabla de datos. Esto luego nos permitirá manipular una variable basada en los resultados de otra. Por ejemplo, podremos ordenar los nombres de los estados por el número de asesinatos. Consejo: R viene con una muy buena funcionalidad de autocompletar que nos ahorra la molestia de escribir todos los nombres. Intenta escribir murders$p luego presionando la tecla tab en su teclado. Esta funcionalidad y muchas otras funciones útiles de autocompletar están disponibles cuando se trabaja en RStudio. 2.4.4 Vectores: numéricos, caracteres y lógicos El objeto murders$population no es un número sino varios. Llamamos a este tipo de objetos vectores. Un solo número es técnicamente un vector de longitud 1, pero en general usamos el término vectores para referirnos a objetos con varias entradas. La función length te dice cuántas entradas hay en el vector: pop &lt;- murders$population length(pop) #&gt; [1] 51 Este vector particular es numeric ya que los tamaños de población son números: class(pop) #&gt; [1] &quot;numeric&quot; En un vector numérico, cada entrada debe ser un número. Para almacenar cadenas de caracteres, los vectores también pueden ser de la clase caracter. Por ejemplo, los nombres de estado son caracteres: class(murders$state) #&gt; [1] &quot;character&quot; Al igual que con los vectores numéricos, todas las entradas en un vector de caracteres deben ser un carácter. Otro tipo importante de vectores son los vectores lógicos. Estos deben ser TRUE o FALSE. z &lt;- 3 == 2 z #&gt; [1] FALSE class(z) #&gt; [1] &quot;logical&quot; Aquí el == es un operador relacional que pregunta si 3 es igual a 2. En R, si solo usa uno =, en realidad asigna una variable, pero si usa dos == prueba para la igualdad. Puede ver los otros operadores relacionales escribiendo: ?Comparison En secciones futuras, verá cuán útiles pueden ser los operadores relacionales. Discutimos características más importantes de los vectores después del siguiente conjunto de ejercicios. Avanzado: Matemáticamente, los valores en pop son enteros y hay una clase de enteros en R. Sin embargo, de manera predeterminada, a los números se les asigna una clase numérica incluso cuando son enteros redondos. Por ejemplo, class(1) devuelve numérico Puede convertirlos en un entero de clase con el as.integer() función o agregando un L me gusta esto: 1L. Tenga en cuenta la clase escribiendo: class(1L) 2.4.5 Factores En el murders conjunto de datos, podríamos esperar que la región también sea un vector de caracteres. Sin embargo, no es: class(murders$region) #&gt; [1] &quot;factor&quot; Es un factor. Los factores son útiles para almacenar datos categóricos. Podemos ver que solo hay 4 regiones utilizando el levels función: levels(murders$region) #&gt; [1] &quot;Northeast&quot; &quot;South&quot; &quot;North Central&quot; &quot;West&quot; En el fondo, R almacena estos niveles como enteros y mantiene un mapa para realizar un seguimiento de las etiquetas. Esto es más eficiente en memoria que almacenar todos los caracteres. Tenga en cuenta que los niveles tienen un orden que es diferente del orden de aparición en el objeto factor. El valor predeterminado es que los niveles sigan el orden alfabético. Sin embargo, a menudo queremos que los niveles sigan un orden diferente. Veremos varios ejemplos de esto en la parte de visualización de datos del libro. La función reorder nos permite cambiar el orden de los niveles de una variable de factor en función de un resumen calculado en un vector numérico. Vamos a demostrar esto con un simple ejemplo. Supongamos que queremos los niveles de la región por el número total de asesinatos en lugar de por orden alfabético. Si hay valores asociados con cada nivel, podemos usar el reorder y especifique un resumen de datos para determinar el orden. El siguiente código toma la suma del total de asesinatos en cada región y reordena el factor siguiendo estas sumas. region &lt;- murders$region value &lt;- murders$total region &lt;- reorder(region, value, FUN = sum) levels(region) #&gt; [1] &quot;Northeast&quot; &quot;North Central&quot; &quot;West&quot; &quot;South&quot; El nuevo orden está de acuerdo con el hecho de que el noreste tiene menos asesinatos y el sur tiene más. Advertencia: los factores pueden ser una fuente de confusión, ya que a veces se comportan como personajes y otras no. Como resultado, los factores y caracteres confusos son una fuente común de errores. 2.4.6 Listas Los marcos de datos son un caso especial de lists. Cubriremos las listas con más detalle más adelante, pero sabemos que son útiles porque puede almacenar cualquier combinación de diferentes tipos. A continuación se muestra un ejemplo de una lista que creamos para usted: record #&gt; $name #&gt; [1] &quot;John Doe&quot; #&gt; #&gt; $student_id #&gt; [1] 1234 #&gt; #&gt; $grades #&gt; [1] 95 82 91 97 93 #&gt; #&gt; $final_grade #&gt; [1] &quot;A&quot; class(record) #&gt; [1] &quot;list&quot; Al igual que con los marcos de datos, puede extraer los componentes de una lista con el descriptor de acceso $. De hecho, los marcos de datos son un tipo de lista. record$student_id #&gt; [1] 1234 También podemos usar corchetes dobles ( [[) me gusta esto: record[[&quot;student_id&quot;]] #&gt; [1] 1234 Debería acostumbrarse al hecho de que en R, a menudo hay varias formas de hacer lo mismo, como acceder a las entradas. También puede encontrar listas sin nombres de variables. record2 #&gt; [[1]] #&gt; [1] &quot;John Doe&quot; #&gt; #&gt; [[2]] #&gt; [1] 1234 Si una lista no tiene nombres, no puede extraer los elementos con $, pero aún puede usar el método de corchetes y, en lugar de proporcionar el nombre de la variable, proporciona el índice de la lista, de esta manera: record2[[1]] #&gt; [1] &quot;John Doe&quot; No usaremos listas hasta más tarde, pero puede encontrar uno en su propia exploración de R. Por esta razón, le mostramos algunos conceptos básicos aquí. 2.4.7 Matrices Las matrices son otro tipo de objeto que son comunes en R. Las matrices son similares a los marcos de datos en que son bidimensionales: tienen filas y columnas. Sin embargo, al igual que los vectores numéricos, de caracteres y lógicos, las entradas en matrices deben ser del mismo tipo. Por esta razón, los marcos de datos son mucho más útiles para almacenar datos, ya que podemos tener caracteres, factores y números en ellos. Sin embargo, las matrices tienen una gran ventaja sobre los marcos de datos: podemos realizar operaciones de álgebra matricial, un poderoso tipo de técnica matemática. No describimos estas operaciones en este libro, pero gran parte de lo que sucede en segundo plano cuando realiza un análisis de datos involucra matrices. Cubrimos las matrices con más detalle en el Capítulo ?? pero descríbalos brevemente aquí, ya que algunas de las funciones que aprenderemos devuelven matrices. Podemos definir una matriz usando el matrix función. Necesitamos especificar el número de filas y columnas. mat &lt;- matrix(1:12, 4, 3) mat #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 Puede acceder a entradas específicas en una matriz usando corchetes ( [) Si desea la segunda fila, tercera columna, usa: mat[2, 3] #&gt; [1] 10 Si desea toda la segunda fila, deje el lugar de la columna vacío: mat[2, ] #&gt; [1] 2 6 10 Tenga en cuenta que esto devuelve un vector, no una matriz. Del mismo modo, si desea la tercera columna completa, deje el lugar de la fila vacío: mat[, 3] #&gt; [1] 9 10 11 12 Esto también es un vector, no una matriz. Puede acceder a más de una columna o más de una fila si lo desea. Esto te dará una nueva matriz. mat[, 2:3] #&gt; [,1] [,2] #&gt; [1,] 5 9 #&gt; [2,] 6 10 #&gt; [3,] 7 11 #&gt; [4,] 8 12 Puede subconjuntar tanto filas como columnas: mat[1:2, 2:3] #&gt; [,1] [,2] #&gt; [1,] 5 9 #&gt; [2,] 6 10 Podemos convertir matrices en marcos de datos usando la función as.data.frame: as.data.frame(mat) #&gt; V1 V2 V3 #&gt; 1 1 5 9 #&gt; 2 2 6 10 #&gt; 3 3 7 11 #&gt; 4 4 8 12 También puede usar corchetes individuales ( [) para acceder a filas y columnas de un marco de datos: data(&quot;murders&quot;) murders[25, 1] #&gt; [1] &quot;Mississippi&quot; murders[2:3, ] #&gt; state abb region population total #&gt; 2 Alaska AK West 710231 19 #&gt; 3 Arizona AZ West 6392017 232 2.5 Ejercicios 1. Cargue el conjunto de datos de asesinatos de EE. UU. library(dslabs) data(murders) Usa la función str para examinar la estructura de la murders objeto. ¿Cuál de las siguientes opciones describe mejor las variables representadas en este marco de datos? Los 51 estados. si. Las tasas de asesinatos para los 50 estados y DC. El nombre del estado, la abreviatura del nombre del estado, la región del estado y la población del estado y el número total de asesinatos para 2010. re. str no muestra información relevante. 2. ¿Cuáles son los nombres de columna utilizados por el marco de datos para estas cinco variables? 3. Usa el descriptor de acceso $ para extraer las abreviaturas de estado y asignarlas al objeto a. ¿Cuál es la clase de este objeto? 4. Ahora use los corchetes para extraer las abreviaturas de estado y asignarlas al objeto b. Utilizar el identical función para determinar si a y b son lo mismo. 5. Vimos que el region la columna almacena un factor. Puede corroborar esto escribiendo: class(murders$region) Con una línea de código, use la función levels y length para determinar el número de regiones definidas por este conjunto de datos. 6. La función table toma un vector y devuelve la frecuencia de cada elemento. Puede ver rápidamente cuántos estados hay en cada región aplicando esta función. Use esta función en una línea de código para crear una tabla de estados por región. 2.6 Vectores En R, los objetos más básicos disponibles para almacenar datos son vectores. Como hemos visto, los conjuntos de datos complejos generalmente se pueden dividir en componentes que son vectores. Por ejemplo, en un marco de datos, cada columna es un vector. Aquí aprendemos más sobre esta importante clase. 2.6.1 Crear vectores Podemos crear vectores usando la función c, que significa concatenate. Usamos c para concatenar entradas de la siguiente manera: codes &lt;- c(380, 124, 818) codes #&gt; [1] 380 124 818 También podemos crear vectores de caracteres. Usamos las comillas para denotar que las entradas son caracteres en lugar de nombres de variables. country &lt;- c(&quot;italy&quot;, &quot;canada&quot;, &quot;egypt&quot;) En R también puedes usar comillas simples: country &lt;- c(&#39;italy&#39;, &#39;canada&#39;, &#39;egypt&#39;) Pero tenga cuidado de no confundir la comilla simple ‘con la back quote’. A estas alturas ya debería saber que si escribe: country &lt;- c(italy, canada, egypt) recibes un error porque las variables italy, canada y egypt no están definidos. Si no usamos las comillas, R busca variables con esos nombres y devuelve un error. 2.6.2 Nombres A veces es útil nombrar las entradas de un vector. Por ejemplo, al definir un vector de códigos de país, podemos usar los nombres para conectar los dos: codes &lt;- c(italy = 380, canada = 124, egypt = 818) codes #&gt; italy canada egypt #&gt; 380 124 818 El objeto codes sigue siendo un vector numérico: class(codes) #&gt; [1] &quot;numeric&quot; pero con nombres: names(codes) #&gt; [1] &quot;italy&quot; &quot;canada&quot; &quot;egypt&quot; Si el uso de cadenas sin comillas parece confuso, sepa que también puede usar las comillas: codes &lt;- c(&quot;italy&quot; = 380, &quot;canada&quot; = 124, &quot;egypt&quot; = 818) codes #&gt; italy canada egypt #&gt; 380 124 818 No hay diferencia entre esta llamada de función y la anterior. Esta es una de las muchas formas en que R es peculiar en comparación con otros lenguajes. También podemos asignar nombres usando el names funciones: codes &lt;- c(380, 124, 818) country &lt;- c(&quot;italy&quot;,&quot;canada&quot;,&quot;egypt&quot;) names(codes) &lt;- country codes #&gt; italy canada egypt #&gt; 380 124 818 2.6.3 Secuencias Otra función útil para crear vectores genera secuencias: seq(1, 10) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 El primer argumento define el inicio, y el segundo define el final que se incluye. El valor predeterminado es subir en incrementos de 1, pero un tercer argumento nos permite decir cuánto saltar: seq(1, 10, 2) #&gt; [1] 1 3 5 7 9 Si queremos enteros consecutivos, podemos usar la siguiente taquigrafía: 1:10 #&gt; [1] 1 2 3 4 5 6 7 8 9 10 Cuando usamos estas funciones, R produce números enteros, no numéricos, porque generalmente se usan para indexar algo: class(1:10) #&gt; [1] &quot;integer&quot; Sin embargo, si creamos una secuencia que incluye no enteros, la clase cambia: class(seq(1, 10, 0.5)) #&gt; [1] &quot;numeric&quot; 2.6.4 Subconjunto Usamos corchetes para acceder a elementos específicos de un vector. Para el vector codes que definimos anteriormente, podemos acceder al segundo elemento usando: codes[2] #&gt; canada #&gt; 124 Puede obtener más de una entrada utilizando un vector de entradas múltiples como índice: codes[c(1,3)] #&gt; italy egypt #&gt; 380 818 Las secuencias definidas anteriormente son particularmente útiles si queremos acceder, digamos, a los dos primeros elementos: codes[1:2] #&gt; italy canada #&gt; 380 124 Si los elementos tienen nombres, también podemos acceder a las entradas utilizando estos nombres. A continuación hay dos ejemplos. codes[&quot;canada&quot;] #&gt; canada #&gt; 124 codes[c(&quot;egypt&quot;,&quot;italy&quot;)] #&gt; egypt italy #&gt; 818 380 2.7 Coerción En general, coercion es un intento de R de ser flexible con los tipos de datos. Cuando una entrada no coincide con lo esperado, algunas de las funciones R preconstruidas intentan adivinar lo que significaba antes de arrojar un error. Esto también puede conducir a la confusión. Si no se comprende la coerción, los programadores pueden volverse locos al intentar codificar en R, ya que se comporta de manera bastante diferente a la mayoría de los otros idiomas a este respecto. Aprendamos sobre esto con algunos ejemplos. Dijimos que los vectores deben ser todos del mismo tipo. Entonces, si tratamos de combinar, digamos, números y caracteres, puede esperar un error: x &lt;- c(1, &quot;canada&quot;, 3) ¡Pero no tenemos uno, ni siquiera una advertencia! ¿Que pasó? Mirar x y su clase: x #&gt; [1] &quot;1&quot; &quot;canada&quot; &quot;3&quot; class(x) #&gt; [1] &quot;character&quot; R coerció los datos en caracteres. Supuso que debido a que pones una cadena de caracteres en el vector, querías decir que el 1 y el 3 en realidad son cadenas de caracteres &quot;1&quot; y &quot; 3&amp;Quot;. El hecho de que ni siquiera se emita una advertencia es un ejemplo de cómo la coerción puede causar muchos errores inadvertidos en R. R también ofrece funciones para cambiar de un tipo a otro. Por ejemplo, puede convertir números en caracteres con: x &lt;- 1:5 y &lt;- as.character(x) y #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; Puedes devolverlo con as.numeric: as.numeric(y) #&gt; [1] 1 2 3 4 5 Esta función es realmente bastante útil ya que los conjuntos de datos que incluyen números como cadenas de caracteres son comunes. 2.7.1 No disponible (NA) Cuando una función intenta forzar un tipo a otro y encuentra un caso imposible, generalmente nos da una advertencia y convierte la entrada en un valor especial llamado NA para “no disponible”. Por ejemplo: x &lt;- c(&quot;1&quot;, &quot;b&quot;, &quot;3&quot;) as.numeric(x) #&gt; Warning: NAs introducidos por coerción #&gt; [1] 1 NA 3 R no tiene ninguna conjetura sobre el número que desea cuando escribe b, por lo que no lo intenta. Como científico de datos, se encontrará con el NA a menudo, como se usan generalmente para datos faltantes, un problema común en los conjuntos de datos del mundo real. 2.8 Ejercicios 1. Usa la función c para crear un vector con las temperaturas altas promedio en enero para Beijing, Lagos, París, Río de Janeiro, San Juan y Toronto, que son 35, 88, 42, 84, 81 y 30 grados Fahrenheit. Llamar al objeto temp. 2. Ahora crea un vector con los nombres de las ciudades y llama al objeto city. 3. Utilizar el names función y los objetos definidos en los ejercicios anteriores para asociar los datos de temperatura con su ciudad correspondiente. 4. Utilizar el [ y : operadores para acceder a la temperatura de las tres primeras ciudades de la lista. 5. Utilizar el [ operador para acceder a la temperatura de París y San Juan. 6. Utilizar el : operador para crear una secuencia de números \\(12,13,14,\\dots,73\\). 7. Cree un vector que contenga todos los números impares positivos menores que 100. 8. Cree un vector de números que comience en 6, no pase 55 y agregue números en incrementos de 4/7: 6, 6 + 4/7, 6 + 8/7, y así sucesivamente. ¿Cuántos números tiene la lista? Sugerencia: uso seq y length. 9. ¿Cuál es la clase del siguiente objeto? a &lt;- seq(1, 10, 0.5)? 10. ¿Cuál es la clase del siguiente objeto? a &lt;- seq(1, 10)? 11. La clase de class(a&lt;-1) es numérico, no entero. R por defecto es numérico y para forzar un número entero, debe agregar la letra L. Confirme que la clase de 1L es entero 12. Defina el siguiente vector: x &lt;- c(&quot;1&quot;, &quot;3&quot;, &quot;5&quot;) y obligarlo a obtener enteros. ##Clasificación Ahora que hemos dominado algunos conocimientos básicos de R, intentemos obtener algunos conocimientos sobre la seguridad de los diferentes estados en el contexto de los asesinatos con armas de fuego. 2.8.1 sort Digamos que queremos clasificar los estados desde el menor hasta la mayoría de los asesinatos con armas de fuego. La función sort ordena un vector en orden creciente. Por lo tanto, podemos ver la mayor cantidad de asesinatos de armas escribiendo: library(dslabs) data(murders) sort(murders$total) #&gt; [1] 2 4 5 5 7 8 11 12 12 16 19 21 22 #&gt; [14] 27 32 36 38 53 63 65 67 84 93 93 97 97 #&gt; [27] 99 111 116 118 120 135 142 207 219 232 246 250 286 #&gt; [40] 293 310 321 351 364 376 413 457 517 669 805 1257 Sin embargo, esto no nos da información sobre qué estados tienen qué asesinatos totales. Por ejemplo, no sabemos qué estado tenía 1257. 2.8.2 order La función order está más cerca de lo que queremos Toma un vector como entrada y devuelve el vector de índices que clasifica el vector de entrada. Esto puede sonar confuso, así que veamos un ejemplo simple. Podemos crear un vector y ordenarlo: x &lt;- c(31, 4, 15, 92, 65) sort(x) #&gt; [1] 4 15 31 65 92 En lugar de ordenar el vector de entrada, la función order devuelve el índice que ordena el vector de entrada: index &lt;- order(x) x[index] #&gt; [1] 4 15 31 65 92 Este es el mismo resultado que el devuelto por sort(x). Si miramos este índice, vemos por qué funciona: x #&gt; [1] 31 4 15 92 65 order(x) #&gt; [1] 2 3 1 5 4 La segunda entrada de x es el más pequeño, entonces order(x) comienza con 2. La siguiente más pequeña es la tercera entrada, por lo que la segunda entrada es 3 y así. ¿Cómo nos ayuda esto a ordenar los estados por asesinatos? Primero, recuerde que las entradas de vectores a las que accede $ siga el mismo orden que las filas de la tabla. Por ejemplo, estos dos vectores que contienen nombres de estado y abreviaturas, respectivamente, se corresponden por su orden: murders$state[1:6] #&gt; [1] &quot;Alabama&quot; &quot;Alaska&quot; &quot;Arizona&quot; &quot;Arkansas&quot; &quot;California&quot; #&gt; [6] &quot;Colorado&quot; murders$abb[1:6] #&gt; [1] &quot;AL&quot; &quot;AK&quot; &quot;AZ&quot; &quot;AR&quot; &quot;CA&quot; &quot;CO&quot; Esto significa que podemos ordenar los nombres de estado por sus asesinatos totales. Primero obtenemos el índice que ordena los vectores según los totales de asesinatos y luego indexamos el vector de nombres de estado: ind &lt;- order(murders$total) murders$abb[ind] #&gt; [1] &quot;VT&quot; &quot;ND&quot; &quot;NH&quot; &quot;WY&quot; &quot;HI&quot; &quot;SD&quot; &quot;ME&quot; &quot;ID&quot; &quot;MT&quot; &quot;RI&quot; &quot;AK&quot; &quot;IA&quot; &quot;UT&quot; #&gt; [14] &quot;WV&quot; &quot;NE&quot; &quot;OR&quot; &quot;DE&quot; &quot;MN&quot; &quot;KS&quot; &quot;CO&quot; &quot;NM&quot; &quot;NV&quot; &quot;AR&quot; &quot;WA&quot; &quot;CT&quot; &quot;WI&quot; #&gt; [27] &quot;DC&quot; &quot;OK&quot; &quot;KY&quot; &quot;MA&quot; &quot;MS&quot; &quot;AL&quot; &quot;IN&quot; &quot;SC&quot; &quot;TN&quot; &quot;AZ&quot; &quot;NJ&quot; &quot;VA&quot; &quot;NC&quot; #&gt; [40] &quot;MD&quot; &quot;OH&quot; &quot;MO&quot; &quot;LA&quot; &quot;IL&quot; &quot;GA&quot; &quot;MI&quot; &quot;PA&quot; &quot;NY&quot; &quot;FL&quot; &quot;TX&quot; &quot;CA&quot; Según lo anterior, California tuvo la mayor cantidad de asesinatos. 2.8.3 max y which.max Si solo estamos interesados en la entrada con el mayor valor, podemos usar max por el valor: max(murders$total) #&gt; [1] 1257 y which.max para el índice del mayor valor: i_max &lt;- which.max(murders$total) murders$state[i_max] #&gt; [1] &quot;California&quot; Como mínimo, podemos usar min y which.min del mismo modo. ¿Significa esto que California es el estado más peligroso? En una próxima sección, argumentamos que deberíamos considerar las tasas en lugar de los totales. Antes de hacer eso, presentamos una última función relacionada con el orden: rank. 2.8.4 rank Aunque no se usa con tanta frecuencia como order y sort, la función rank también está relacionado con el orden y puede ser útil. Para cualquier vector dado, devuelve un vector con el rango de la primera entrada, segunda entrada, etc., del vector de entrada. Aquí hay un ejemplo simple: x &lt;- c(31, 4, 15, 92, 65) rank(x) #&gt; [1] 3 1 2 5 4 Para resumir, veamos los resultados de las tres funciones que hemos introducido: original sort order rank 31 4 2 3 4 15 3 1 15 31 1 2 92 65 5 5 65 92 4 4 2.8.5 Cuidado con el reciclaje Otra fuente común de errores inadvertidos en R es el uso de recycling. Vimos que los vectores se agregan por elementos. Entonces, si los vectores no coinciden en longitud, es natural suponer que deberíamos obtener un error. Pero nosotros no. Note lo que pasa: x &lt;- c(1,2,3) y &lt;- c(10, 20, 30, 40, 50, 60, 70) x+y #&gt; Warning in x + y: longitud de objeto mayor no es múltiplo de la longitud #&gt; de uno menor #&gt; [1] 11 22 33 41 52 63 71 Recibimos una advertencia, pero no hay error. Para la salida, R ha reciclado los números en x. Observe el último dígito de números en la salida. 2.9 Ejercicios Para estos ejercicios usaremos el conjunto de datos de asesinatos de Estados Unidos. Asegúrese de cargarlo antes de comenzar. library(dslabs) data(&quot;murders&quot;) 1. Utilizar el $ operador para acceder a los datos del tamaño de la población y almacenarlos como el objeto pop. Luego usa el sort función para redefinir pop para que esté ordenado Finalmente, usa el [ operador para informar el tamaño de población más pequeño. 2. Ahora, en lugar del tamaño de población más pequeño, encuentre el índice de la entrada con el tamaño de población más pequeño. Sugerencia: uso order en lugar de sort. 3. Realmente podemos realizar la misma operación que en el ejercicio anterior usando la función which.min. Escribe una línea de código que haga esto. 4. Ahora sabemos cuán pequeño es el estado más pequeño y sabemos qué fila lo representa. Que estado es Definir una variable. states ser los nombres de estado de la murders marco de datos. Informe el nombre del estado con la población más pequeña. 5. Puede crear un marco de datos utilizando el data.frame función. Aquí hay un ejemplo rápido: temp &lt;- c(35, 88, 42, 84, 81, 30) city &lt;- c(&quot;Beijing&quot;, &quot;Lagos&quot;, &quot;Paris&quot;, &quot;Rio de Janeiro&quot;, &quot;San Juan&quot;, &quot;Toronto&quot;) city_temps &lt;- data.frame(name = city, temperature = temp) Utilizar el rank función para determinar el rango de población de cada estado desde el tamaño de población más pequeño hasta el más grande. Guarde estos rangos en un objeto llamado ranks, luego cree un marco de datos con el nombre del estado y su rango. Llamar al marco de datos my_df. 6. Repita el ejercicio anterior, pero esta vez ordene my_df para que los estados se ordenen de menos poblados a más poblados. Sugerencia: crea un objeto ind que almacena los índices necesarios para ordenar los valores de la población. Luego use el operador de soporte [ para reordenar cada columna en el marco de datos. 7. Los na_example el vector representa una serie de recuentos. Puede examinar rápidamente el objeto usando: data(&quot;na_example&quot;) str(na_example) #&gt; int [1:1000] 2 1 3 2 1 3 1 4 3 2 ... Sin embargo, cuando calculamos el promedio con la función mean, obtenemos un NA: mean(na_example) #&gt; [1] NA Los is.na la función devuelve un vector lógico que nos dice qué entradas son NA. Asigne este vector lógico a un objeto llamado ind y determina cuantos NA s hace na_example tener. 8. Ahora calcule el promedio nuevamente, pero solo para las entradas que no son NA. Pista: recuerda el ! operador. 2.10 Aritmética de vectores California tuvo la mayor cantidad de asesinatos, pero ¿esto significa que es el estado más peligroso? ¿Qué pasa si solo tiene muchas más personas que cualquier otro estado? Podemos confirmar rápidamente que California tiene la mayor población: library(dslabs) data(&quot;murders&quot;) murders$state[which.max(murders$population)] #&gt; [1] &quot;California&quot; con más de 37 millones de habitantes Por lo tanto, es injusto comparar los totales si estamos interesados en saber qué tan seguro es el estado. Lo que realmente deberíamos calcular son los asesinatos per cápita. Los informes que describimos en la sección motivadora utilizaron asesinatos por cada 100,000 como la unidad. Para calcular esta cantidad, las poderosas capacidades aritméticas de vectores de R son útiles. 2.10.1 Reescalando un vector En R, las operaciones aritméticas en vectores ocurren elemento-sabio. Para un ejemplo rápido, supongamos que tenemos la altura en pulgadas: inches &lt;- c(69, 62, 66, 70, 70, 73, 67, 73, 67, 70) y quiero convertir a centímetros. Note lo que sucede cuando multiplicamos inches por 2.54: inches * 2.54 #&gt; [1] 175 157 168 178 178 185 170 185 170 178 En la línea de arriba, multiplicamos cada elemento por 2.54. Del mismo modo, si para cada entrada queremos calcular cuántas pulgadas más alto o más corto que 69 pulgadas, la altura promedio para los hombres, podemos restarlo de cada entrada de esta manera: inches - 69 #&gt; [1] 0 -7 -3 1 1 4 -2 4 -2 1 2.10.2 Dos vectores Si tenemos dos vectores de la misma longitud y los sumamos en R, se agregarán entrada por entrada de la siguiente manera: \\[ \\begin{pmatrix} a\\\\ b\\\\ c\\\\ d \\end{pmatrix} + \\begin{pmatrix} e\\\\ f\\\\ g\\\\ h \\end{pmatrix} = \\begin{pmatrix} a +e\\\\ b + f\\\\ c + g\\\\ d + h \\end{pmatrix} \\] Lo mismo vale para otras operaciones matemáticas, como -, * y /. Esto implica que para calcular las tasas de asesinatos simplemente podemos escribir: murder_rate &lt;- murders$total/ murders$population * 100000 Una vez que hacemos esto, notamos que California ya no está cerca de la parte superior de la lista. De hecho, podemos usar lo que hemos aprendido para ordenar a los estados por tasa de asesinatos: murders$abb[order(murder_rate)] #&gt; [1] &quot;VT&quot; &quot;NH&quot; &quot;HI&quot; &quot;ND&quot; &quot;IA&quot; &quot;ID&quot; &quot;UT&quot; &quot;ME&quot; &quot;WY&quot; &quot;OR&quot; &quot;SD&quot; &quot;MN&quot; &quot;MT&quot; #&gt; [14] &quot;CO&quot; &quot;WA&quot; &quot;WV&quot; &quot;RI&quot; &quot;WI&quot; &quot;NE&quot; &quot;MA&quot; &quot;IN&quot; &quot;KS&quot; &quot;NY&quot; &quot;KY&quot; &quot;AK&quot; &quot;OH&quot; #&gt; [27] &quot;CT&quot; &quot;NJ&quot; &quot;AL&quot; &quot;IL&quot; &quot;OK&quot; &quot;NC&quot; &quot;NV&quot; &quot;VA&quot; &quot;AR&quot; &quot;TX&quot; &quot;NM&quot; &quot;CA&quot; &quot;FL&quot; #&gt; [40] &quot;TN&quot; &quot;PA&quot; &quot;AZ&quot; &quot;GA&quot; &quot;MS&quot; &quot;MI&quot; &quot;DE&quot; &quot;SC&quot; &quot;MD&quot; &quot;MO&quot; &quot;LA&quot; &quot;DC&quot; 2.11 Ejercicios 1. Anteriormente creamos este marco de datos: temp &lt;- c(35, 88, 42, 84, 81, 30) city &lt;- c(&quot;Beijing&quot;, &quot;Lagos&quot;, &quot;Paris&quot;, &quot;Rio de Janeiro&quot;, &quot;San Juan&quot;, &quot;Toronto&quot;) city_temps &lt;- data.frame(name = city, temperature = temp) Vuelva a crear el marco de datos utilizando el código anterior, pero agregue una línea que convierta la temperatura de Fahrenheit a Celsius. La conversión es \\(C = \\frac{5}{9} \\times (F - 32)\\). 2. ¿Cuál es la siguiente suma? \\(1+1/2^2 + 1/3^2 + \\dots 1/100^2\\)? Sugerencia: gracias a Euler, sabemos que debería estar cerca de \\(\\pi^2/6\\). 3. Calcule la tasa de asesinatos por cada 100,000 para cada estado y almacénela en el objeto murder_rate. Luego calcule la tasa promedio de asesinatos para los EE. UU. Con la función mean. ¿Cuál es el promedio? 2.12 Indexación R proporciona una forma poderosa y conveniente de indexar vectores. Podemos, por ejemplo, subconjuntar un vector en función de las propiedades de otro vector. En esta sección, continuamos trabajando con nuestro ejemplo de asesinatos en EE. UU., Que podemos cargar así: library(dslabs) data(&quot;murders&quot;) 2.12.1 Subconjunto con lógicas Ahora hemos calculado la tasa de asesinatos usando: murder_rate &lt;- murders$total/ murders$population * 100000 Imagine que se muda de Italia donde, según un informe de noticias de ABC, la tasa de asesinatos es de solo 0.71 por 100,000. Preferiría mudarse a un estado con una tasa de homicidios similar. Otra característica poderosa de R es que podemos usar lógicas para indexar vectores. Si comparamos un vector con un solo número, en realidad realiza la prueba para cada entrada. El siguiente es un ejemplo relacionado con la pregunta anterior: ind &lt;- murder_rate &lt; 0.71 Si en cambio queremos saber si un valor es menor o igual, podemos usar: ind &lt;- murder_rate &lt;= 0.71 Tenga en cuenta que recuperamos un vector lógico con TRUE para cada entrada menor o igual a 0.71. Para ver qué estados son estos, podemos aprovechar el hecho de que los vectores pueden indexarse con lógicos. murders$state[ind] #&gt; [1] &quot;Hawaii&quot; &quot;Iowa&quot; &quot;New Hampshire&quot; &quot;North Dakota&quot; #&gt; [5] &quot;Vermont&quot; Para contar cuántos son VERDADEROS, la función sum devuelve la suma de las entradas de un vector y los vectores lógicos se coerced a numéricos con TRUE codificado como 1 y FALSE como 0. Así podemos contar los estados usando: sum(ind) #&gt; [1] 5 2.12.2 Operadores logicos Supongamos que nos gustan las montañas y queremos mudarnos a un estado seguro en la región occidental del país. Queremos que la tasa de asesinatos sea como máximo 1. En este caso, queremos que dos cosas diferentes sean ciertas. Aquí podemos usar el operador lógico y, que en R se representa con &amp;. Esta operación da como resultado TRUE solo cuando ambas lógicas son TRUE. Para ver esto, considere este ejemplo: TRUE &amp; TRUE #&gt; [1] TRUE TRUE &amp; FALSE #&gt; [1] FALSE FALSE &amp; FALSE #&gt; [1] FALSE Para nuestro ejemplo, podemos formar dos lógicas: west &lt;- murders$region == &quot;West&quot; safe &lt;- murder_rate &lt;= 1 y podemos usar el &amp; para obtener un vector de lógicas que nos dice qué estados satisfacen ambas condiciones: ind &lt;- safe &amp; west murders$state[ind] #&gt; [1] &quot;Hawaii&quot; &quot;Idaho&quot; &quot;Oregon&quot; &quot;Utah&quot; &quot;Wyoming&quot; 2.12.3 which Supongamos que queremos ver la tasa de asesinatos de California. Para este tipo de operación, es conveniente convertir vectores de lógicos en índices en lugar de mantener largos vectores de lógicos. La función which nos dice qué entradas de un vector lógico son VERDADERAS. Entonces podemos escribir: ind &lt;- which(murders$state == &quot;California&quot;) murder_rate[ind] #&gt; [1] 3.37 2.12.4 match Si en lugar de un solo estado queremos averiguar las tasas de homicidio de varios estados, digamos Nueva York, Florida y Texas, podemos usar la función match. Esta función nos dice qué índices de un segundo vector coinciden con cada una de las entradas de un primer vector: ind &lt;- match(c(&quot;New York&quot;, &quot;Florida&quot;, &quot;Texas&quot;), murders$state) ind #&gt; [1] 33 10 44 Ahora podemos ver las tasas de asesinatos: murder_rate[ind] #&gt; [1] 2.67 3.40 3.20 2.12.5 %in% Si en lugar de un índice queremos una lógica que nos diga si cada elemento de un primer vector está en un segundo, podemos usar la función %in%. Imaginemos que no está seguro de si Boston, Dakota y Washington son estados. Puedes averiguar así: c(&quot;Boston&quot;, &quot;Dakota&quot;, &quot;Washington&quot;) %in% murders$state #&gt; [1] FALSE FALSE TRUE Tenga en cuenta que estaremos usando %in% a menudo a lo largo del libro. Avanzado: hay una conexión entre match y %in% mediante which. Para ver esto, observe que las siguientes dos líneas producen el mismo índice (aunque en diferente orden): match(c(&quot;New York&quot;, &quot;Florida&quot;, &quot;Texas&quot;), murders$state) #&gt; [1] 33 10 44 which(murders$state%in%c(&quot;New York&quot;, &quot;Florida&quot;, &quot;Texas&quot;)) #&gt; [1] 10 33 44 2.13 Ejercicios Comience cargando la biblioteca y los datos. library(dslabs) data(murders) 1. Calcule la tasa de asesinatos por cada 100,000 para cada estado y almacénela en un objeto llamado murder_rate. Luego use operadores lógicos para crear un vector lógico llamado low eso nos dice qué entradas de murder_rate son inferiores a 1. 2. Ahora use los resultados del ejercicio anterior y la función which para determinar los índices de murder_rate asociado con valores inferiores a 1. 3. Use los resultados del ejercicio anterior para informar los nombres de los estados con tasas de asesinatos inferiores a 1. 4. Ahora extienda el código de los ejercicios 2 y 3 para informar los estados del noreste con tasas de homicidios inferiores a 1. Sugerencia: use el vector lógico previamente definido low y el operador lógico &amp;. 5. En un ejercicio anterior, calculamos la tasa de homicidios para cada estado y el promedio de estos números. ¿Cuántos estados están por debajo del promedio? 6. Use la función de coincidencia para identificar los estados con abreviaturas AK, MI e IA. Sugerencia: comience definiendo un índice de las entradas de murders$abb que coinciden con las tres abreviaturas, luego use el [ operador para extraer los estados. 7. Utilizar el %in% operador para crear un vector lógico que responda a la pregunta: ¿cuáles de las siguientes son abreviaturas reales: MA, ME, MI, MO, MU? 8. Extienda el código que usó en el ejercicio 7 para informar la entrada que no es no una abreviatura real. Sugerencia: use el ! operador, que gira FALSE dentro TRUE y viceversa, entonces which para obtener un índice. 2.14 Parcelas básicas En el capitulo ?? describimos un paquete complementario que proporciona un enfoque poderoso para producir gráficos en R. Luego tenemos una parte completa sobre la visualización de datos en la que proporcionamos muchos ejemplos. Aquí describimos brevemente algunas de las funciones que están disponibles en una instalación básica de R. 2.14.1 plot Los plot la función se puede utilizar para hacer diagramas de dispersión. Aquí hay una trama de asesinatos totales versus población. x &lt;- murders$population/ 10^6 y &lt;- murders$total plot(x, y) Para una trama rápida que evita el acceso a las variables dos veces, podemos usar el with función: with(murders, plot(population, total)) La función with vamos a usar el murders nombres de columna en el plot función. También funciona con cualquier marco de datos y cualquier función. 2.14.2 hist Describiremos los histogramas en relación con las distribuciones en la parte de visualización de datos del libro. Aquí simplemente notaremos que los histogramas son un poderoso resumen gráfico de una lista de números que le brinda una visión general de los tipos de valores que tiene. Podemos hacer un histograma de nuestras tasas de asesinatos simplemente escribiendo: x &lt;- with(murders, total/ population * 100000) hist(x) Podemos ver que hay una amplia gama de valores con la mayoría de ellos entre 2 y 3 y un caso muy extremo con una tasa de asesinatos de más de 15: murders$state[which.max(x)] #&gt; [1] &quot;District of Columbia&quot; 2.14.3 boxplot Los diagramas de caja también se describirán en la parte de visualización de datos del libro. Proporcionan un resumen más conciso que los histogramas, pero son más fáciles de apilar con otros diagramas de caja. Por ejemplo, aquí podemos usarlos para comparar las diferentes regiones: murders$rate &lt;- with(murders, total/ population * 100000) boxplot(rate~region, data = murders) Podemos ver que el Sur tiene tasas de asesinatos más altas que las otras tres regiones. 2.14.4 image La función de imagen muestra los valores en una matriz usando color. Aquí hay un ejemplo rápido: x &lt;- matrix(1:120, 12, 10) image(x) 2.15 Ejercicios 1. Hicimos una trama de asesinatos totales versus población y notamos una fuerte relación. No es sorprendente que los estados con poblaciones más grandes hayan tenido más asesinatos. library(dslabs) data(murders) population_in_millions &lt;- murders$population/10^6 total_gun_murders &lt;- murders$total plot(population_in_millions, total_gun_murders) Tenga en cuenta que muchos estados tienen poblaciones inferiores a 5 millones y están agrupados. Podemos obtener más información al hacer este diagrama en la escala logarítmica. Transforme las variables usando el log10 transformación y luego trazarlos. 2. Crea un histograma de las poblaciones estatales. 3. Generar diagramas de caja de las poblaciones estatales por región. https://rstudio.cloud↩ https://rafalab.github.io/dsbook/installing-r-rstudio.html↩ http://abcnews.go.com/blogs/headlines/2012/12/us-gun-ownership -homicide-rate-superior-que-otros-países-desarrollados/↩ http://adv-r.had.co.nz/Style.html↩ "],
["conceptos-basicos-de-programacion.html", "Capítulo 3 Conceptos básicos de programación 3.1 Expresiones condicionales 3.2 Definiendo funciones 3.3 Espacios de nombres 3.4 For-loops 3.5 Vectorización y funcionales 3.6 Ejercicios", " Capítulo 3 Conceptos básicos de programación Enseñamos R porque facilita enormemente el análisis de datos, el tema principal de este libro. Al codificar en R, podemos realizar eficientemente análisis de datos exploratorios, construir canales de análisis de datos y preparar la visualización de datos para comunicar los resultados. Sin embargo, R no es solo un entorno de análisis de datos sino un lenguaje de programación. Los programadores avanzados de R pueden desarrollar paquetes complejos e incluso mejorar la propia R, pero no cubrimos la programación avanzada en este libro. No obstante, en esta sección, presentamos tres conceptos clave de programación: expresiones condicionales, bucles for y funciones. Estos no son solo bloques de construcción clave para la programación avanzada, sino que a veces son útiles durante el análisis de datos. También notamos que hay varias funciones que se usan ampliamente para programar en R pero que no cubriremos en este libro. Éstos incluyen split, cut, do.call y Reduce, así como el paquete data.table. Vale la pena aprenderlos si planea convertirse en un programador experto de R. 3.1 Expresiones condicionales Las expresiones condicionales son una de las características básicas de la programación. Se utilizan para lo que se llama flow control. La expresión condicional más común es la declaración if-else. En R, podemos realizar bastante análisis de datos sin condicionales. Sin embargo, aparecen ocasionalmente, y los necesitará una vez que comience a escribir sus propias funciones y paquetes. Aquí hay un ejemplo muy simple que muestra la estructura general de una instrucción if-else. La idea básica es imprimir el recíproco de a a no ser que a es 0: a &lt;- 0 if(a!=0){ print(1/a) } else{ print(&quot;No reciprocal for 0.&quot;) } #&gt; [1] &quot;No reciprocal for 0.&quot; Veamos un ejemplo más usando el marco de datos de asesinatos de Estados Unidos: library(dslabs) data(murders) murder_rate &lt;- murders$total/ murders$population*100000 Aquí hay un ejemplo muy simple que nos dice qué estados, si los hay, tienen una tasa de homicidios inferior a 0.5 por 100,000. los if declaración nos protege del caso en el que ningún estado satisface la condición. ind &lt;- which.min(murder_rate) if(murder_rate[ind] &lt; 0.5){ print(murders$state[ind]) } else{ print(&quot;No state has murder rate that low&quot;) } #&gt; [1] &quot;Vermont&quot; Si lo intentamos nuevamente con una tasa de 0.25, obtenemos una respuesta diferente: if(murder_rate[ind] &lt; 0.25){ print(murders$state[ind]) } else{ print(&quot;No state has a murder rate that low.&quot;) } #&gt; [1] &quot;No state has a murder rate that low.&quot; Una función relacionada que es muy útil es ifelse. Esta función toma tres argumentos: una lógica y dos posibles respuestas. Si lo lógico es TRUE, se devuelve el valor en el segundo argumento y si FALSE, se devuelve el valor en el tercer argumento. Aquí hay un ejemplo: a &lt;- 0 ifelse(a &gt; 0, 1/a, NA) #&gt; [1] NA La función es particularmente útil porque funciona en vectores. Examina cada entrada del vector lógico y devuelve elementos del vector proporcionado en el segundo argumento, si la entrada es TRUE, o elementos del vector proporcionados en el tercer argumento, si la entrada es FALSE. a &lt;- c(0, 1, 2, -4, 5) result &lt;- ifelse(a &gt; 0, 1/a, NA) Esta tabla nos ayuda a ver qué sucedió: a is_a_positive answer1 answer2 result 0 FALSE Inf NA NA 1 TRUE 1.00 NA 1.0 2 TRUE 0.50 NA 0.5 -4 FALSE -0.25 NA NA 5 TRUE 0.20 NA 0.2 Aquí hay un ejemplo de cómo esta función se puede usar fácilmente para reemplazar todos los valores faltantes en un vector con ceros: data(na_example) no_nas &lt;- ifelse(is.na(na_example), 0, na_example) sum(is.na(no_nas)) #&gt; [1] 0 Otras dos funciones útiles son any y all. Los any la función toma un vector de lógicas y devuelve TRUE si alguna de las entradas es TRUE. Los all la función toma un vector de lógicas y devuelve TRUE si todas las entradas son TRUE. Aquí hay un ejemplo: z &lt;- c(TRUE, TRUE, FALSE) any(z) #&gt; [1] TRUE all(z) #&gt; [1] FALSE 3.2 Definiendo funciones A medida que adquieras más experiencia, necesitarás realizar las mismas operaciones una y otra vez. Un ejemplo simple es el cálculo de promedios. Podemos calcular el promedio de un vector x utilizando la sum y length funciones: sum(x)/length(x). Debido a que hacemos esto repetidamente, es mucho más eficiente escribir una función que realice esta operación. Esta operación particular es tan común que alguien ya escribió el mean función y se incluye en la base R. Sin embargo, se encontrará con situaciones en las que la función aún no existe, por lo que R le permite escribir la suya. Una versión simple de una función que calcula el promedio se puede definir así: avg &lt;- function(x){ s &lt;- sum(x) n &lt;- length(x) s/n } Ahora avg es una función que calcula la media: x &lt;- 1:100 identical(mean(x), avg(x)) #&gt; [1] TRUE Observe que las variables definidas dentro de una función no se guardan en el espacio de trabajo. Entonces mientras usamos s y n cuando llamamos avg, los valores se crean y cambian solo durante la llamada. Aquí hay un ejemplo ilustrativo: s &lt;- 3 avg(1:10) #&gt; [1] 5.5 s #&gt; [1] 3 Tenga en cuenta cómo s es todavía 3 después de que llamemos avg. En general, las funciones son objetos, por lo que las asignamos a nombres de variables con &lt;-. La función function le dice a R que está a punto de definir una función. La forma general de una definición de función se ve así: my_function &lt;- function(VARIABLE_NAME){ perform operations on VARIABLE_NAME and calculate VALUE VALUE } Las funciones que defina pueden tener múltiples argumentos, así como valores predeterminados. Por ejemplo, podemos definir una función que calcule el promedio aritmético o geométrico dependiendo de una variable definida por el usuario como esta: avg &lt;- function(x, arithmetic = TRUE){ n &lt;- length(x) ifelse(arithmetic, sum(x)/n, prod(x)^(1/n)) } Aprenderemos más sobre cómo crear funciones a través de la experiencia a medida que nos enfrentamos a tareas más complejas. 3.3 Espacios de nombres Una vez que comience a convertirse en un usuario experto de R, es probable que necesite cargar varios paquetes de complementos para algunos de sus análisis. Una vez que comience a hacer esto, es probable que dos paquetes usen el mismo nombre para dos funciones diferentes. Y a menudo estas funciones hacen cosas completamente diferentes. De hecho, ya te has encontrado con esto porque tanto __dplyr__como el paquete R__base__stats__ definen un filter función. Hay otros cinco ejemplos en dplyr. Sabemos esto porque cuando cargamos dplyr por primera vez, vemos el siguiente mensaje: The following objects are masked from ‘package:stats’: filter, lag The following objects are masked from ‘package:base’: intersect, setdiff, setequal, union Entonces, ¿qué hace R cuando escribimos filter? ¿Utiliza la función __dplyr__o la funciónstats? De nuestro trabajo anterior sabemos que usa el dplyr uno. Pero, ¿qué pasa si queremos usar la versión stats? Estas funciones viven en diferentes espacios de nombres. R seguirá un cierto orden cuando busque una función en estos espacios de nombres. Puede ver el pedido escribiendo: search() La primera entrada en esta lista es el entorno global que incluye todos los objetos que defina. Entonces, ¿qué pasa si queremos usar las stats filter en lugar del filtro __dplyr__perodplyr aparece primero en la lista de búsqueda? Puede forzar el uso de un espacio de nombre específico utilizando dos puntos dobles ( ::) me gusta esto: stats::filter Si queremos estar absolutamente seguros de que usamos el dplyr filter nosotros podemos usar dplyr::filter También tenga en cuenta que si queremos usar una función en un paquete sin cargar el paquete completo, también podemos usar los dos puntos dobles. Para más información sobre este tema más avanzado, recomendamos el libro de paquetes R14. 3.4 For-loops La fórmula para la suma de la serie. \\(1+2+\\dots+n\\) es \\(n(n+1)/2\\). ¿Qué pasaría si no estuviéramos seguros de que esa era la función correcta? ¿Cómo podríamos verificar? Usando lo que aprendimos sobre las funciones, podemos crear una que calcule \\(S_n\\): compute_s_n &lt;- function(n){ x &lt;- 1:n sum(x) } ¿Cómo podemos calcular \\(S_n\\) para varios valores de \\(n\\) decir \\(n=1,\\dots,25\\)? ¿Escribimos 25 líneas de código compute_s_n? No, para eso están los bucles for en la programación. En este caso, estamos realizando exactamente la misma tarea una y otra vez, y lo único que está cambiando es el valor de \\(n\\). Los bucles for nos permiten definir el rango que toma nuestra variable (en nuestro ejemplo \\(n=1,\\dots,10\\)), luego cambie el valor y evalúe la expresión a medida que realiza un bucle. Quizás el ejemplo más simple de un bucle for es este código inútil: for(i in 1:5){ print(i) } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 Aquí está el ciclo for que escribiríamos para nuestro \\(S_n\\) ejemplo: m &lt;- 25 s_n &lt;- vector(length = m) # create an empty vector for(n in 1:m){ s_n[n] &lt;- compute_s_n(n) } En cada iteración \\(n=1\\), \\(n=2\\), etc …, calculamos \\(S_n\\) y guardarlo en el \\(n\\) th entrada de s_n. Ahora podemos crear un diagrama para buscar un patrón: n &lt;- 1:m plot(n, s_n) Si notó que parece ser un elemento cuadrático, está en el camino correcto porque la fórmula es \\(n(n+1)/2\\). 3.5 Vectorización y funcionales Aunque los bucles for son un concepto importante para entender, en R rara vez los usamos. A medida que aprenda más R, se dará cuenta de que se prefiere la vectorización sobre los bucles for ya que da como resultado un código más corto y claro. Ya vimos ejemplos en la sección Aritmética de vectores. Una función vectorizada es una función que aplicará la misma operación en cada uno de los vectores. x &lt;- 1:10 sqrt(x) #&gt; [1] 1.00 1.41 1.73 2.00 2.24 2.45 2.65 2.83 3.00 3.16 y &lt;- 1:10 x*y #&gt; [1] 1 4 9 16 25 36 49 64 81 100 Para hacer este cálculo, no hay necesidad de for-loops. Sin embargo, no todas las funciones funcionan de esta manera. Por ejemplo, la función que acabamos de escribir, compute_s_n, no funciona por elementos, ya que espera un escalar. Este fragmento de código no ejecuta la función en cada entrada de n: n &lt;- 1:25 compute_s_n(n) Funcionales son funciones que nos ayudan a aplicar la misma función a cada entrada en un vector, matriz, marco de datos o lista. Aquí cubrimos el funcional que opera en vectores numéricos, lógicos y de caracteres: sapply. La función sapply nos permite realizar operaciones basadas en elementos en cualquier función. Así es como funciona: x &lt;- 1:10 sapply(x, sqrt) #&gt; [1] 1.00 1.41 1.73 2.00 2.24 2.45 2.65 2.83 3.00 3.16 Cada elemento de x se pasa a la función sqrt y se devuelve el resultado. Estos resultados están concatenados. En este caso, el resultado es un vector de la misma longitud que el original x. Esto implica que el ciclo for anterior puede escribirse de la siguiente manera: n &lt;- 1:25 s_n &lt;- sapply(n, compute_s_n) Otros funcionales son apply, lapply, tapply, mapply, vapply y replicate. Usamos principalmente sapply, apply y replicate en este libro, pero recomendamos familiarizarse con los demás, ya que pueden ser muy útiles. 3.6 Ejercicios 1. ¿Qué devolverá esta expresión condicional? x &lt;- c(1,2,-3,4) if(all(x&gt;0)){ print(&quot;All Postives&quot;) } else{ print(&quot;Not all positives&quot;) } 2. ¿Cuál de las siguientes expresiones es siempre FALSE cuando al menos una entrada de un vector lógico x ¿es verdad? all(x) si. any(x) any(!x) re. all(!x) 3. La función nchar le dice cuántos caracteres tiene un vector de caracteres. Escriba una línea de código que se asigne al objeto. new_names la abreviatura del estado cuando el nombre del estado tiene más de 8 caracteres. 4. Crear una función sum_n que para cualquier valor dado, digamos \\(n\\), calcula la suma de los enteros de 1 a n (inclusive). Use la función para determinar la suma de los enteros de 1 a 5,000. 5. Crear una función altman_plot eso toma dos argumentos, x y y, y traza la diferencia contra la suma. 6. Después de ejecutar el siguiente código, ¿cuál es el valor de x? x &lt;- 3 my_func &lt;- function(y){ x &lt;- 5 y+5 } 7. Escribir una función compute_s_n que para cualquier \\(n\\) calcula la suma \\(S_n = 1^2 + 2^2 + 3^2 + \\dots n^2\\). Informe el valor de la suma cuando \\(n=10\\). 8. Definir un vector numérico vacío. s_n de tamaño 25 usando s_n &lt;- vector(&quot;numeric&quot;, 25) y almacenar en los resultados de \\(S_1, S_2, \\dots S_{25}\\) usando un bucle for. 9. Repita el ejercicio 8, pero esta vez use sapply. 10. Repita el ejercicio 8, pero esta vez use map_dbl. 11. Trama \\(S_n\\) versus \\(n\\). Use puntos definidos por \\(n=1,\\dots,25\\). 12. Confirme que la fórmula para esta suma es \\(S_n= n(n+1)(2n+1)/6\\). http://r-pkgs.had.co.nz/namespace.html↩ "],
["tidyverse.html", "Capítulo 4 El tidyverse 4.1 Datos ordenados 4.2 Ejercicios 4.3 Manipulación de marcos de datos 4.4 Ejercicios 4.5 El tubo: %&gt;% 4.6 Ejercicios 4.7 Resumiendo datos 4.8 Ordenar marcos de datos 4.9 Ejercicios 4.10 Tibbles 4.11 El operador punto 4.12 do 4.13 El paquete purrr 4.14 Tidyverse condicionales 4.15 Ejercicios", " Capítulo 4 El tidyverse Hasta ahora hemos estado manipulando vectores reordenándolos y subconjuntándolos mediante indexación. Sin embargo, una vez que comenzamos los análisis más avanzados, la unidad preferida para el almacenamiento de datos no es el vector sino el marco de datos. En este capítulo aprendemos a trabajar directamente con marcos de datos, que facilitan enormemente la organización de la información. Utilizaremos marcos de datos para la mayoría de este libro. Nos centraremos en un formato de datos específico denominado tidy_y en una colección específica de paquetes que son particularmente útiles para trabajar con_tidy_datos denominados_tidyverse. Podemos cargar todos los paquetes tidyverse a la vez instalando y cargando el paquete tidyverse: library(tidyverse) Aprenderemos cómo implementar el enfoque tidyverse a lo largo del libro, pero antes de profundizar en los detalles, en este capítulo presentamos algunas de las funciones tidyverse más utilizadas, comenzando con el paquete __dplyr__para manipular marcos de datos y el paquetepurrr para trabajar con funciones Tenga en cuenta que tidyverse también incluye un paquete de gráficos, ggplot2, que presentaremos más adelante en el Capítulo ?? en la parte de visualización de datos del libro; el paquete readr discutido en el Capítulo 5; y muchos otros. En este capítulo, primero presentamos el concepto de tidy data y luego demostramos cómo usamos el tidyverse para trabajar con marcos de datos en este formato. 4.1 Datos ordenados Decimos que una tabla de datos está en formato tidy si cada fila representa una observación y las columnas representan las diferentes variables disponibles para cada una de estas observaciones. los murders el conjunto de datos es un ejemplo de un marco de datos ordenado. #&gt; state abb region population total #&gt; 1 Alabama AL South 4779736 135 #&gt; 2 Alaska AK West 710231 19 #&gt; 3 Arizona AZ West 6392017 232 #&gt; 4 Arkansas AR South 2915918 93 #&gt; 5 California CA West 37253956 1257 #&gt; 6 Colorado CO West 5029196 65 Cada fila representa un estado con cada una de las cinco columnas que proporcionan una variable diferente relacionada con estos estados: nombre, abreviatura, región, población y asesinatos totales. Para ver cómo se puede proporcionar la misma información en diferentes formatos, considere el siguiente ejemplo: #&gt; country year fertility #&gt; 1 Germany 1960 2.41 #&gt; 2 South Korea 1960 6.16 #&gt; 3 Germany 1961 2.44 #&gt; 4 South Korea 1961 5.99 #&gt; 5 Germany 1962 2.47 #&gt; 6 South Korea 1962 5.79 Este conjunto de datos ordenado proporciona tasas de fertilidad para dos países a lo largo de los años. Este es un conjunto de datos ordenado porque cada fila presenta una observación con las tres variables: país, año y tasa de fecundidad. Sin embargo, este conjunto de datos originalmente vino en otro formato y se reformó para el paquete dslabs. Originalmente, los datos estaban en el siguiente formato: #&gt; country 1960 1961 1962 #&gt; 1 Germany 2.41 2.44 2.47 #&gt; 2 South Korea 6.16 5.99 5.79 Se proporciona la misma información, pero hay dos diferencias importantes en el formato: 1) cada fila incluye varias observaciones y 2) una de las variables, año, se almacena en el encabezado. Para que los paquetes tidyverse se utilicen de manera óptima, los datos deben ser reformados en tidy formato, que aprenderá a hacer en la parte del Libro de disputas de datos. Hasta entonces, utilizaremos conjuntos de datos de ejemplo que ya están en formato ordenado. Aunque no es inmediatamente obvio, a medida que avance en el libro comenzará a apreciar las ventajas de trabajar en un marco en el que las funciones usan formatos ordenados tanto para las entradas como para las salidas. Verá cómo esto permite que el analista de datos se centre en aspectos más importantes del análisis en lugar del formato de los datos. 4.2 Ejercicios 1. Examinar el conjunto de datos incorporado. co2. Cual de los siguientes es verdadero: co2 son datos ordenados: tiene un año para cada fila. si. co2 no es ordenado: necesitamos al menos una columna con un vector de caracteres. co2 no es ordenado: es una matriz en lugar de un marco de datos. re. co2 no es ordenado: para ser ordenado tendríamos que arreglarlo para tener tres columnas (año, mes y valor), luego cada observación de CO2 tendría una fila. 2. Examinar el conjunto de datos incorporado. ChickWeight. Cual de los siguientes es verdadero: ChickWeight no está ordenado: cada pollito tiene más de una fila. si. ChickWeight es ordenado: cada observación (un peso) está representada por una fila. La chica de la que provino esta medición es una de las variables. ChickWeight no está ordenado: nos falta la columna del año. re. ChickWeight es ordenado: se almacena en un marco de datos. 3. Examinar el conjunto de datos incorporado. BOD. Cual de los siguientes es verdadero: BOD no está ordenado: solo tiene seis filas. si. BOD no es ordenado: la primera columna es solo un índice. BOD es ordenado: cada fila es una observación con dos valores (tiempo y demanda) re. BOD es ordenado: todos los conjuntos de datos pequeños son ordenados por definición. 4. ¿Cuál de los siguientes conjuntos de datos integrados está ordenado (puede elegir más de uno): BJsales si. EuStockMarkets re. DNase re. Formaldehyde Orange UCBAdmissions 4.3 Manipulación de marcos de datos El paquete __dplyr__deltidyverse introduce funciones que realizan algunas de las operaciones más comunes cuando se trabaja con marcos de datos y usa nombres para estas funciones que son relativamente fáciles de recordar. Por ejemplo, para cambiar la tabla de datos agregando una nueva columna, utilizamos mutate. Para filtrar la tabla de datos a un subconjunto de filas, utilizamos filter. Finalmente, para subdividir los datos seleccionando columnas específicas, usamos select. 4.3.1 Agregar una columna con mutate Queremos que toda la información necesaria para nuestro análisis se incluya en la tabla de datos. Entonces, la primera tarea es agregar las tasas de asesinatos a nuestro marco de datos de asesinatos. La función mutate toma el marco de datos como primer argumento y el nombre y los valores de la variable como segundo argumento usando la convención name = values. Entonces, para agregar tasas de asesinatos, usamos: library(dslabs) data(&quot;murders&quot;) murders &lt;- mutate(murders, rate = total/ population * 100000) Tenga en cuenta que aquí usamos total y population dentro de la función, que son objetos no definidos en nuestro espacio de trabajo. Pero, ¿por qué no recibimos un error? Esta es una de las principales características de dplyr. Funciones en este paquete, como mutate, sepa buscar variables en el marco de datos proporcionado en el primer argumento. En la llamada a mutar arriba, total tendrá los valores en murders$total. Este enfoque hace que el código sea mucho más legible. Podemos ver que se agrega la nueva columna: head(murders) #&gt; state abb region population total rate #&gt; 1 Alabama AL South 4779736 135 2.82 #&gt; 2 Alaska AK West 710231 19 2.68 #&gt; 3 Arizona AZ West 6392017 232 3.63 #&gt; 4 Arkansas AR South 2915918 93 3.19 #&gt; 5 California CA West 37253956 1257 3.37 #&gt; 6 Colorado CO West 5029196 65 1.29 Aunque hemos sobrescrito el original murders objeto, esto no cambia el objeto que se cargó con data(murders). Si cargamos el murders nuevamente, el original sobrescribirá nuestra versión mutada. 4.3.2 Subconjunto con filter Ahora suponga que queremos filtrar la tabla de datos para mostrar solo las entradas para las que la tasa de homicidios es inferior a 0,71. Para hacer esto usamos el filter función, que toma la tabla de datos como primer argumento y luego la declaración condicional como el segundo. Me gusta mutate, podemos usar los nombres de variables sin comillas de murders dentro de la función y sabrá que nos referimos a las columnas y no a los objetos en el espacio de trabajo. filter(murders, rate &lt;= 0.71) #&gt; state abb region population total rate #&gt; 1 Hawaii HI West 1360301 7 0.515 #&gt; 2 Iowa IA North Central 3046355 21 0.689 #&gt; 3 New Hampshire NH Northeast 1316470 5 0.380 #&gt; 4 North Dakota ND North Central 672591 4 0.595 #&gt; 5 Vermont VT Northeast 625741 2 0.320 4.3.3 Seleccionar columnas con select Aunque nuestra tabla de datos solo tiene seis columnas, algunas tablas de datos incluyen cientos. Si queremos ver solo algunos, podemos usar el dplyr select función. En el siguiente código seleccionamos tres columnas, asignamos esto a un nuevo objeto y luego filtramos el nuevo objeto: new_table &lt;- select(murders, state, region, rate) filter(new_table, rate &lt;= 0.71) #&gt; state region rate #&gt; 1 Hawaii West 0.515 #&gt; 2 Iowa North Central 0.689 #&gt; 3 New Hampshire Northeast 0.380 #&gt; 4 North Dakota North Central 0.595 #&gt; 5 Vermont Northeast 0.320 En la llamada a select, el primer argumento murders es un objeto, pero state, region y rate son nombres de variables 4.4 Ejercicios 1. Cargue el paquete dplyr y el conjunto de datos de asesinatos. library(dplyr) library(dslabs) data(murders) Puede agregar columnas usando la función dplyr mutate. Esta función conoce los nombres de columna y dentro de la función puede llamarlos sin comillas: murders &lt;- mutate(murders, population_in_millions = population/ 10^6) Podemos escribir population más bien que murders$population. La función mutate sabe que estamos agarrando columnas de murders. Usa la función mutate para agregar una columna de asesinatos llamada rate con la tasa de asesinatos por 100,000 como en el código de ejemplo anterior. Asegúrate de redefinir murders como se hizo en el código de ejemplo anterior (asesinatos &lt;- [su código]) para que podamos seguir usando esta variable. 2. Si rank(x) te da las filas de x de menor a mayor, rank(-x) te da los rangos de mayor a menor. Usa la función mutate para agregar una columna rank que contiene el rango, de mayor a menor índice de asesinatos. Asegúrate de redefinir murders para que podamos seguir usando esta variable. 3. Con dplyr, podemos usar select para mostrar solo ciertas columnas. Por ejemplo, con este código solo mostraríamos los estados y los tamaños de población: select(murders, state, population) %&gt;% head() Utilizar select para mostrar los nombres de estado y abreviaturas en murders. No redefinir murders, solo muestra los resultados. 4. La función dplyr filter se utiliza para elegir filas específicas del marco de datos para mantener. diferente a select que es para columnas, filter es para filas Por ejemplo, puede mostrar solo la fila de Nueva York de esta manera: filter(murders, state == &quot;New York&quot;) Puede usar otros vectores lógicos para filtrar filas. Utilizar filter para mostrar los 5 principales estados con las tasas de asesinatos más altas. Después de agregar la tasa y rango de asesinatos, no cambie el conjunto de datos de asesinatos, solo muestre el resultado. Recuerde que puede filtrar en función de rank columna. 5. Podemos eliminar filas usando el != operador. Por ejemplo, para eliminar Florida, haríamos esto: no_florida &lt;- filter(murders, state != &quot;Florida&quot;) Crear un nuevo marco de datos llamado no_south que elimina estados de la región sur. ¿Cuántos estados hay en esta categoría? Puedes usar la función nrow para esto. 6. También podemos usar %in% para filtrar con dplyr. Por lo tanto, puede ver los datos de Nueva York y Texas de esta manera: filter(murders, state %in% c(&quot;New York&quot;, &quot;Texas&quot;)) Crear un nuevo marco de datos llamado murders_nw con solo los estados del noreste y oeste. ¿Cuántos estados hay en esta categoría? 7. Suponga que desea vivir en el noreste u oeste y desea que la tasa de homicidios sea inferior a 1. Queremos ver los datos de los estados que satisfacen estas opciones. Tenga en cuenta que puede usar operadores lógicos con filter. Aquí hay un ejemplo en el que filtramos para mantener solo estados pequeños en la región noreste. filter(murders, population &lt; 5000000 &amp; region == &quot;Northeast&quot;) Asegurarse murders ha sido definido con rate y rank y todavía tiene todos los estados. Crea una tabla llamada my_states que contiene filas para estados que satisfacen ambas condiciones: está en el noreste u oeste y la tasa de homicidios es inferior a 1. Use select para mostrar solo el nombre del estado, la tasa y el rango. 4.5 El tubo: %&gt;% Con dplyr podemos realizar una serie de operaciones, por ejemplo select y entonces filter, enviando los resultados de una función a otra usando lo que se llama pipe operator: %&gt;%. Algunos detalles se incluyen a continuación. Escribimos el código anterior para mostrar tres variables (estado, región, tasa) para los estados que tienen tasas de asesinatos por debajo de 0,71. Para hacer esto, definimos el objeto intermedio new_table. En dplyr podemos escribir código que se parezca más a una descripción de lo que queremos hacer sin objetos intermedios: \\[ \\mbox {original data } \\rightarrow \\mbox { select } \\rightarrow \\mbox { filter } \\] Para tal operación, podemos usar la tubería %&gt;%. El código se ve así: murders %&gt;% select(state, region, rate) %&gt;% filter(rate &lt;= 0.71) #&gt; state region rate #&gt; 1 Hawaii West 0.515 #&gt; 2 Iowa North Central 0.689 #&gt; 3 New Hampshire Northeast 0.380 #&gt; 4 North Dakota North Central 0.595 #&gt; 5 Vermont Northeast 0.320 Esta línea de código es equivalente a las dos líneas de código anteriores. ¿Que esta pasando aqui? En general, la tubería envía el resultado del lado izquierdo de la tubería como el primer argumento de la función en el lado derecho de la tubería. Aquí hay un ejemplo muy simple: 16 %&gt;% sqrt() #&gt; [1] 4 Podemos continuar canalizando valores a lo largo de: 16 %&gt;% sqrt() %&gt;% log2() #&gt; [1] 2 La declaración anterior es equivalente a log2(sqrt(16)). Recuerde que la tubería envía valores al primer argumento, por lo que podemos definir otros argumentos como si el primer argumento ya estuviera definido: 16 %&gt;% sqrt() %&gt;% log(base = 2) #&gt; [1] 2 Por lo tanto, al usar la tubería con marcos de datos y dplyr, ya no necesitamos especificar el primer argumento requerido ya que las funciones dplyr que hemos descrito toman todos los datos como el primer argumento. En el código que escribimos: murders %&gt;% select(state, region, rate) %&gt;% filter(rate &lt;= 0.71) murders es el primer argumento de la select función, y el nuevo marco de datos (anteriormente new_table) es el primer argumento de la filter función. Tenga en cuenta que la tubería funciona bien con funciones donde el primer argumento son los datos de entrada. Las funciones en los paquetes __tidyverse__comodplyr tienen este formato y se pueden usar fácilmente con la tubería. 4.6 Ejercicios 1. El tubo %&gt;% se puede usar para realizar operaciones secuencialmente sin tener que definir objetos intermedios. Comience redefiniendo el asesinato para incluir la tasa y el rango. murders &lt;- mutate(murders, rate = total/ population * 100000, rank = rank(-rate)) En la solución al ejercicio anterior, hicimos lo siguiente: my_states &lt;- filter(murders, region %in% c(&quot;Northeast&quot;, &quot;West&quot;) &amp; rate &lt; 1) select(my_states, state, rate, rank) El tubo %&gt;% nos permite realizar ambas operaciones secuencialmente sin tener que definir una variable intermedia my_states. Por lo tanto, podríamos haber mutado y seleccionado en la misma línea de esta manera: mutate(murders, rate = total/ population * 100000, rank = rank(-rate)) %&gt;% select(state, rate, rank) Darse cuenta de select ya no tiene un marco de datos como primer argumento. Se supone que el primer argumento es el resultado de la operación realizada justo antes de %&gt;%. Repita el ejercicio anterior, pero ahora, en lugar de crear un nuevo objeto, muestre el resultado y solo incluya las columnas de estado, velocidad y rango. Usar una pipa %&gt;% para hacer esto en una sola línea. 2. Reiniciar murders a la tabla original usando data(murders). Use una tubería para crear un nuevo marco de datos llamado my_states que considera solo los estados del noreste u oeste que tienen una tasa de homicidios inferior a 1 y contiene solo las columnas de estado, tasa y rango. La tubería también debe tener cuatro componentes separados por tres %&gt;%. El código debería verse así: my_states &lt;- murders %&gt;% mutate SOMETHING %&gt;% filter SOMETHING %&gt;% select SOMETHING 4.7 Resumiendo datos Una parte importante del análisis exploratorio de datos es resumir los datos. La desviación promedio y estándar son dos ejemplos de estadísticas de resumen ampliamente utilizadas. A menudo se pueden obtener resúmenes más informativos dividiendo primero los datos en grupos. En esta sección, cubrimos dos nuevos verbos dplyr que facilitan estos cálculos: summarize y group_by. Aprendemos a acceder a los valores resultantes utilizando el pull función. 4.7.1 summarize Los summarize la función dplyr proporciona una forma de calcular estadísticas de resumen con código intuitivo y legible. Comenzamos con un ejemplo simple basado en alturas. los heights el conjunto de datos incluye las alturas y el sexo reportado por los estudiantes en una encuesta en clase. library(dplyr) library(dslabs) data(heights) El siguiente código calcula la desviación promedio y estándar para las mujeres: s &lt;- heights %&gt;% filter(sex == &quot;Female&quot;) %&gt;% summarize(average = mean(height), standard_deviation = sd(height)) s #&gt; average standard_deviation #&gt; 1 64.9 3.76 Esto toma nuestra tabla de datos original como entrada, la filtra para mantener solo a las mujeres y luego produce una nueva tabla resumida con solo el promedio y la desviación estándar de las alturas. Podemos elegir los nombres de las columnas de la tabla resultante. Por ejemplo, arriba decidimos usar average y standard_deviation, pero podríamos haber usado otros nombres de la misma manera. Porque la tabla resultante almacenada en s es un marco de datos, podemos acceder a los componentes con el descriptor de acceso $: s$average #&gt; [1] 64.9 s$standard_deviation #&gt; [1] 3.76 Como con la mayoría de las otras funciones dplyr, summarize conoce los nombres de las variables y podemos usarlos directamente. Entonces, dentro de la llamada al summarize función que escribimos mean(height), la función accede a la columna con el nombre “altura” y luego calcula el promedio del vector numérico resultante. Podemos calcular cualquier otro resumen que opera en vectores y devuelve un solo valor. Por ejemplo, podemos agregar las alturas mediana, mínima y máxima de esta manera: heights %&gt;% filter(sex == &quot;Female&quot;) %&gt;% summarize(median = median(height), minimum = min(height), maximum = max(height)) #&gt; median minimum maximum #&gt; 1 65 51 79 Podemos obtener estos tres valores con solo una línea usando el quantile función: por ejemplo, quantile(x, c(0,0.5,1)) devuelve el mínimo (percentil 0), la mediana (percentil 50) y el máximo (percentil 100) del vector x. Sin embargo, si intentamos usar una función como esta que devuelve dos o más valores dentro summarize: heights %&gt;% filter(sex == &quot;Female&quot;) %&gt;% summarize(range = quantile(height, c(0, 0.5, 1))) recibiremos un error: Error: expecting result of length one, got : 2. Con la función summarize, solo podemos llamar a funciones que devuelven un solo valor. En la sección 4.12, aprenderemos cómo lidiar con funciones que devuelven más de un valor. Para otro ejemplo de cómo podemos usar el summarize función, calculemos la tasa promedio de asesinatos en los Estados Unidos. Recuerde que nuestra tabla de datos incluye asesinatos totales y el tamaño de la población para cada estado y ya hemos usado dplyr para agregar una columna de índice de asesinatos: murders &lt;- murders %&gt;% mutate(rate = total/population*100000) Recuerde que la tasa de asesinatos en EE. UU. Es no el promedio de las tasas de asesinatos estatales: summarize(murders, mean(rate)) #&gt; mean(rate) #&gt; 1 2.78 Esto se debe a que en el cálculo anterior, los estados pequeños tienen el mismo peso que los grandes. La tasa de homicidios en los Estados Unidos es el número total de asesinatos en los Estados Unidos dividido por la población total de los Estados Unidos. Entonces el cálculo correcto es: us_murder_rate &lt;- murders %&gt;% summarize(rate = sum(total)/ sum(population) * 100000) us_murder_rate #&gt; rate #&gt; 1 3.03 Este cálculo cuenta estados más grandes proporcionalmente a su tamaño, lo que da como resultado un valor mayor. 4.7.2 pull Los us_murder_rate el objeto definido anteriormente representa solo un número. Sin embargo, lo estamos almacenando en un marco de datos: class(us_murder_rate) #&gt; [1] &quot;data.frame&quot; ya que, como la mayoría de las funciones dplyr, summarize siempre devuelve un marco de datos. Esto podría ser problemático si queremos usar este resultado con funciones que requieren un valor numérico. Aquí mostramos un truco útil para acceder a los valores almacenados en los datos cuando se usan tuberías: cuando un objeto de datos se canaliza a ese objeto y se puede acceder a sus columnas usando el pull función. Para entender lo que queremos decir, eche un vistazo a esta línea de código: us_murder_rate %&gt;% pull(rate) #&gt; [1] 3.03 Esto devuelve el valor en el rate columna de us_murder_rate haciéndolo equivalente a us_murder_rate$rate. Para obtener un número de la tabla de datos original con una línea de código, podemos escribir: us_murder_rate &lt;- murders %&gt;% summarize(rate = sum(total)/ sum(population) * 100000) %&gt;% pull(rate) us_murder_rate #&gt; [1] 3.03 que ahora es numérico: class(us_murder_rate) #&gt; [1] &quot;numeric&quot; 4.7.3 Agrupe y luego resuma con group_by Una operación común en la exploración de datos es dividir primero los datos en grupos y luego calcular resúmenes para cada grupo. Por ejemplo, podemos querer calcular la desviación promedio y estándar para las alturas de hombres y mujeres por separado. los group_by la función nos ayuda a hacer esto. Si escribimos esto: heights %&gt;% group_by(sex) #&gt; # A tibble: 1,050 x 2 #&gt; # Groups: sex [2] #&gt; sex height #&gt; &lt;fct&gt; &lt;dbl&gt; #&gt; 1 Male 75 #&gt; 2 Male 70 #&gt; 3 Male 68 #&gt; 4 Male 74 #&gt; 5 Male 61 #&gt; # … with 1,045 more rows El resultado no se ve muy diferente de heights, excepto que vemos Groups: sex [2] cuando imprimimos el objeto. Aunque no es inmediatamente obvio por su apariencia, ahora es un marco de datos especial llamado _marco de datos agrupados_y funcionesdplyr, en particular summarize, se comportará de manera diferente cuando actúe sobre este objeto. Conceptualmente, puede pensar en esta tabla como muchas tablas, con las mismas columnas pero no necesariamente el mismo número de filas, apiladas juntas en un objeto. Cuando resumimos los datos después de la agrupación, esto es lo que sucede: heights %&gt;% group_by(sex) %&gt;% summarize(average = mean(height), standard_deviation = sd(height)) #&gt; # A tibble: 2 x 3 #&gt; sex average standard_deviation #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Female 64.9 3.76 #&gt; 2 Male 69.3 3.61 Los summarize la función aplica el resumen a cada grupo por separado. Para otro ejemplo, calculemos la tasa media de asesinatos en las cuatro regiones del país: murders %&gt;% group_by(region) %&gt;% summarize(median_rate = median(rate)) #&gt; # A tibble: 4 x 2 #&gt; region median_rate #&gt; &lt;fct&gt; &lt;dbl&gt; #&gt; 1 Northeast 1.80 #&gt; 2 South 3.40 #&gt; 3 North Central 1.97 #&gt; 4 West 1.29 4.8 Ordenar marcos de datos Al examinar un conjunto de datos, a menudo es conveniente ordenar la tabla por las diferentes columnas. Sabemos sobre el order y sort función, pero para ordenar tablas enteras, la función dplyr arrange es útil. Por ejemplo, aquí ordenamos los estados por tamaño de población: murders %&gt;% arrange(population) %&gt;% head() #&gt; state abb region population total rate #&gt; 1 Wyoming WY West 563626 5 0.887 #&gt; 2 District of Columbia DC South 601723 99 16.453 #&gt; 3 Vermont VT Northeast 625741 2 0.320 #&gt; 4 North Dakota ND North Central 672591 4 0.595 #&gt; 5 Alaska AK West 710231 19 2.675 #&gt; 6 South Dakota SD North Central 814180 8 0.983 Con arrange podemos decidir por qué columna ordenar. Para ver los estados por población, de menor a mayor, organizamos por rate en lugar: murders %&gt;% arrange(rate) %&gt;% head() #&gt; state abb region population total rate #&gt; 1 Vermont VT Northeast 625741 2 0.320 #&gt; 2 New Hampshire NH Northeast 1316470 5 0.380 #&gt; 3 Hawaii HI West 1360301 7 0.515 #&gt; 4 North Dakota ND North Central 672591 4 0.595 #&gt; 5 Iowa IA North Central 3046355 21 0.689 #&gt; 6 Idaho ID West 1567582 12 0.766 Tenga en cuenta que el comportamiento predeterminado es ordenar en orden ascendente. En dplyr, la función desc transforma un vector para que esté en orden descendente. Para ordenar la tabla en orden descendente, podemos escribir: murders %&gt;% arrange(desc(rate)) 4.8.1 Clasificación anidada Si estamos ordenando por una columna con empates, podemos usar una segunda columna para romper el empate. Del mismo modo, se puede usar una tercera columna para romper los lazos entre la primera y la segunda, y así sucesivamente. Aquí ordenamos por region, luego dentro de la región ordenamos por índice de asesinatos: murders %&gt;% arrange(region, rate) %&gt;% head() #&gt; state abb region population total rate #&gt; 1 Vermont VT Northeast 625741 2 0.320 #&gt; 2 New Hampshire NH Northeast 1316470 5 0.380 #&gt; 3 Maine ME Northeast 1328361 11 0.828 #&gt; 4 Rhode Island RI Northeast 1052567 16 1.520 #&gt; 5 Massachusetts MA Northeast 6547629 118 1.802 #&gt; 6 New York NY Northeast 19378102 517 2.668 4.8.2 La parte superior \\(n\\) En el código anterior, hemos usado la función head para evitar que la página se llene con todo el conjunto de datos. Si queremos ver una mayor proporción, podemos usar el top_n función. Esta función toma un marco de datos como primer argumento, el número de filas para mostrar en el segundo y la variable para filtrar en el tercero. Aquí hay un ejemplo de cómo ver las 5 filas superiores: murders %&gt;% top_n(5, rate) #&gt; state abb region population total rate #&gt; 1 District of Columbia DC South 601723 99 16.45 #&gt; 2 Louisiana LA South 4533372 351 7.74 #&gt; 3 Maryland MD South 5773552 293 5.07 #&gt; 4 Missouri MO North Central 5988927 321 5.36 #&gt; 5 South Carolina SC South 4625364 207 4.48 Tenga en cuenta que las filas no están ordenadas por rate, solo filtrado. Si queremos ordenar, necesitamos usar arrange. Tenga en cuenta que si el tercer argumento se deja en blanco, top_n, filtra por la última columna. 4.9 Ejercicios Para estos ejercicios, utilizaremos los datos de la encuesta recopilada por el Centro Nacional de Estadísticas de Salud de los Estados Unidos (NCHS). Este centro ha realizado una serie de encuestas de salud y nutrición desde la década de 1960. A partir de 1999, alrededor de 5,000 individuos de todas las edades han sido entrevistados cada año y completan el componente de examen de salud de la encuesta. Parte de los datos está disponible a través del paquete NHANES. Una vez que instale el paquete NHANES, puede cargar los datos de esta manera: library(NHANES) data(NHANES) Los datos NHANES tienen muchos valores faltantes. Recuerde que la función de resumen principal en R devolverá NA si alguna de las entradas del vector de entrada es un NA. Aquí hay un ejemplo: library(dslabs) data(na_example) mean(na_example) #&gt; [1] NA sd(na_example) #&gt; [1] NA Ignorar el NA s podemos usar el na.rm argumento: mean(na_example, na.rm = TRUE) #&gt; [1] 2.3 sd(na_example, na.rm = TRUE) #&gt; [1] 1.22 Exploremos ahora los datos de NHANES. 1. Le proporcionaremos algunos datos básicos sobre la presión arterial. Primero, seleccionemos un grupo para establecer el estándar. Utilizaremos hembras de 20 a 29 años. AgeDecade es una variable categórica con estas edades. Tenga en cuenta que la categoría está codificada como “20-29”, ¡con un espacio al frente! ¿Cuál es la desviación promedio y estándar de la presión arterial sistólica como se guarda en el BPSysAve ¿variable? Guárdelo en una variable llamada ref. Sugerencia: uso filter y summarize y usa el na.rm = TRUE argumento al calcular el promedio y la desviación estándar. También puede filtrar los valores de NA utilizando filter. 2. Usando una tubería, asigne el promedio a una variable numérica ref_avg. Sugerencia: use el código similar al anterior y luego pull. 3. Ahora informe los valores mínimo y máximo para el mismo grupo. 4. Calcule el promedio y la desviación estándar para las mujeres, pero para cada grupo de edad por separado en lugar de una década seleccionada como en la pregunta 1. Tenga en cuenta que los grupos de edad se definen por AgeDecade. Sugerencia: en lugar de filtrar por edad y género, filtre por Gender y luego usar group_by. 5. Repita el ejercicio 4 para hombres. 6. De hecho, podemos combinar ambos resúmenes para los ejercicios 4 y 5 en una línea de código. Esto es porque group_by nos permite agrupar por más de una variable. Obtenga una gran tabla resumen usando group_by(AgeDecade, Gender). 7. Para los hombres entre las edades de 40-49, compare la presión arterial sistólica a través de la raza como se informa en el Race1 variable. Ordene la tabla resultante de la presión arterial sistólica promedio más baja a más alta. 4.10 Tibbles Los datos ordenados deben almacenarse en marcos de datos. Introdujimos el marco de datos en la Sección 2.4.1 y he estado usando el murders marco de datos en todo el libro. En la sección 4.7.3 presentamos el group_by función, que permite estratificar datos antes de calcular estadísticas resumidas. Pero, ¿dónde se almacena la información del grupo en el marco de datos? murders %&gt;% group_by(region) #&gt; # A tibble: 51 x 6 #&gt; # Groups: region [4] #&gt; state abb region population total rate #&gt; &lt;chr&gt; &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Alabama AL South 4779736 135 2.82 #&gt; 2 Alaska AK West 710231 19 2.68 #&gt; 3 Arizona AZ West 6392017 232 3.63 #&gt; 4 Arkansas AR South 2915918 93 3.19 #&gt; 5 California CA West 37253956 1257 3.37 #&gt; # … with 46 more rows Tenga en cuenta que no hay columnas con esta información. Pero, si observa de cerca la salida anterior, verá la línea A tibble seguido por dimensiones. Podemos aprender la clase del objeto devuelto usando: murders %&gt;% group_by(region) %&gt;% class() #&gt; [1] &quot;grouped_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Los tbl, pronunciado tibble, es un tipo especial de marco de datos. Las funciones group_by y summarize siempre devuelve este tipo de marco de datos. los group_by la función devuelve un tipo especial de tbl, el grouped_df. Diremos más sobre esto más adelante. Por coherencia, los verbos de manipulación dplyr ( select, filter, mutate y arrange) preservar la clase de la entrada: si reciben un marco de datos regular, devuelven un marco de datos regular, mientras que si reciben un tibble, devuelven un tibble. Pero los tibbles son el formato preferido en el tidyverse y, como resultado, las funciones tidyverse que producen un marco de datos desde cero devuelven un tibble. Por ejemplo, en el capítulo 5 veremos que las funciones tidyverse usadas para importar datos crean tibbles. Los tibbles son muy similares a los marcos de datos. De hecho, puede pensar en ellos como una versión moderna de marcos de datos. Sin embargo, hay tres diferencias importantes que describiremos en el siguiente. 4.10.1 Tibbles se muestran mejor El método de impresión para tibbles es más legible que el de un marco de datos. Para ver esto, compare los resultados de escribir murders y la salida de asesinatos si lo convertimos en un tibble. Podemos hacer esto usando as_tibble(murders). Si usa RStudio, la salida para un tibble se ajusta al tamaño de su ventana. Para ver esto, cambie el ancho de su consola R y observe cómo se muestran más/ menos columnas. 4.10.2 Los subconjuntos de tibbles son tibbles Si subconjuntos las columnas de un marco de datos, puede recuperar un objeto que no es un marco de datos, como un vector o escalar. Por ejemplo: class(murders[,4]) #&gt; [1] &quot;numeric&quot; no es un marco de datos. Con tibbles esto no sucede: class(as_tibble(murders)[,4]) #&gt; [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Esto es útil en tidyverse ya que las funciones requieren marcos de datos como entrada. Con tibbles, si desea acceder al vector que define una columna y no recuperar un marco de datos, debe usar el descriptor de acceso $: class(as_tibble(murders)$population) #&gt; [1] &quot;numeric&quot; Una característica relacionada es que tibbles le dará una advertencia si intenta acceder a una columna que no existe. Si escribimos accidentalmente Population en lugar de population esta: murders$Population #&gt; NULL devuelve un NULL sin advertencia, lo que puede dificultar la depuración. Por el contrario, si intentamos esto con un tibble, obtenemos una advertencia informativa: as_tibble(murders)$Population #&gt; Warning: Unknown or uninitialised column: &#39;Population&#39;. #&gt; NULL 4.10.3 Tibbles puede tener entradas complejas Si bien las columnas del marco de datos deben ser vectores de números, cadenas o valores lógicos, los tibbles pueden tener objetos más complejos, como listas o funciones. Además, podemos crear tibbles con funciones: tibble(id = c(1, 2, 3), func = c(mean, median, sd)) #&gt; # A tibble: 3 x 2 #&gt; id func #&gt; &lt;dbl&gt; &lt;list&gt; #&gt; 1 1 &lt;fn&gt; #&gt; 2 2 &lt;fn&gt; #&gt; 3 3 &lt;fn&gt; 4.10.4 Tibbles se pueden agrupar La función group_by devuelve un tipo especial de tibble: un tibble agrupado. Esta clase almacena información que le permite saber qué filas están en qué grupos. Las funciones tidyverse, en particular la summarize función, son conscientes de la información del grupo. 4.10.5 Crear un tibble usando tibble en lugar de data.frame A veces es útil para nosotros crear nuestros propios marcos de datos. Para crear un marco de datos en formato tibble, puede hacerlo utilizando el tibble función. grades &lt;- tibble(names = c(&quot;John&quot;, &quot;Juan&quot;, &quot;Jean&quot;, &quot;Yao&quot;), exam_1 = c(95, 80, 90, 85), exam_2 = c(90, 85, 85, 90)) Tenga en cuenta que la base R (sin paquetes cargados) tiene una función con un nombre muy similar, data.frame, que se puede usar para crear un marco de datos regular en lugar de un tibble. Otra diferencia importante es que por defecto data.frame coacciona los caracteres en factores sin proporcionar una advertencia o mensaje: grades &lt;- data.frame(names = c(&quot;John&quot;, &quot;Juan&quot;, &quot;Jean&quot;, &quot;Yao&quot;), exam_1 = c(95, 80, 90, 85), exam_2 = c(90, 85, 85, 90)) class(grades$names) #&gt; [1] &quot;factor&quot; Para evitar esto, usamos el argumento bastante engorroso stringsAsFactors: grades &lt;- data.frame(names = c(&quot;John&quot;, &quot;Juan&quot;, &quot;Jean&quot;, &quot;Yao&quot;), exam_1 = c(95, 80, 90, 85), exam_2 = c(90, 85, 85, 90), stringsAsFactors = FALSE) class(grades$names) #&gt; [1] &quot;character&quot; Para convertir un marco de datos normal en un tibble, puede usar el as_tibble función. as_tibble(grades) %&gt;% class() #&gt; [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; 4.11 El operador punto Una de las ventajas de utilizar la tubería. %&gt;% es que no tenemos que seguir nombrando nuevos objetos mientras manipulamos el marco de datos. Como recordatorio rápido, si queremos calcular la tasa de asesinatos promedio para los estados del sur, en lugar de escribir: tab_1 &lt;- filter(murders, region == &quot;South&quot;) tab_2 &lt;- mutate(tab_1, rate = total/ population * 10^5) rates &lt;- tab_2$rate median(rates) #&gt; [1] 3.4 Podemos evitar definir nuevos objetos intermedios escribiendo en su lugar: filter(murders, region == &quot;South&quot;) %&gt;% mutate(rate = total/ population * 10^5) %&gt;% summarize(median = median(rate)) %&gt;% pull(median) #&gt; [1] 3.4 Podemos hacer esto porque cada una de estas funciones toma un marco de datos como primer argumento. Pero, ¿qué pasa si queremos acceder a un componente del marco de datos? Por ejemplo, ¿qué pasa si el pull la función no estaba disponible y queríamos acceder tab_2$rate? ¿Qué nombre de marco de datos usaríamos? La respuesta es el operador de puntos. Por ejemplo, para acceder al vector de velocidad sin el pull función que podríamos usar rates &lt;-filter(murders, region == &quot;South&quot;) %&gt;% mutate(rate = total/ population * 10^5) %&gt;% .$rate median(rates) #&gt; [1] 3.4 En la siguiente sección, veremos otras instancias en las que usar el . es útil. 4.12 do Las funciones tidyverse saben interpretar tibbles agrupados. Además, para facilitar la secuencia de comandos a través de la tubería %&gt;%, las funciones tidyverse devuelven constantemente marcos de datos, ya que esto asegura que la salida de una función sea aceptada como la entrada de otra. Pero la mayoría de las funciones R no reconocen los tibbles agrupados ni devuelven marcos de datos. los quantile la función es un ejemplo que describimos en la Sección 4.7.1. Los do la función sirve como puente entre las funciones R, como quantile y el tidyverse. los do la función comprende tibbles agrupados y siempre devuelve un marco de datos. En la sección 4.7.1, notamos que si intentamos usar quantile para obtener el mínimo, la mediana y el máximo en una llamada, recibiremos un error: Error: expecting result of length one, got : 2. data(heights) heights %&gt;% filter(sex == &quot;Female&quot;) %&gt;% summarize(range = quantile(height, c(0, 0.5, 1))) Podemos usar el do función para arreglar esto. Primero tenemos que escribir una función que se ajuste al enfoque tidyverse: es decir, recibe un marco de datos y devuelve un marco de datos. my_summary &lt;- function(dat){ x &lt;- quantile(dat$height, c(0, 0.5, 1)) tibble(min = x[1], median = x[2], max = x[3]) } Ahora podemos aplicar la función al conjunto de datos de alturas para obtener los resúmenes: heights %&gt;% group_by(sex) %&gt;% my_summary #&gt; # A tibble: 1 x 3 #&gt; min median max #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 50 68.5 82.7 Pero esto no es lo que queremos. Queremos un resumen para cada sexo y el código devolvió solo un resumen. Esto es porque my_summary no es parte del tidyverse y no sabe cómo manejar los tibbles agrupados. do hace esta conexión: heights %&gt;% group_by(sex) %&gt;% do(my_summary(.)) #&gt; # A tibble: 2 x 4 #&gt; # Groups: sex [2] #&gt; sex min median max #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Female 51 65.0 79 #&gt; 2 Male 50 69 82.7 Tenga en cuenta que aquí necesitamos usar el operador de punto. El tibble creado por group_by se canaliza a do. Dentro de la llamada a do, el nombre de este tibble es . y queremos enviarlo a my_summary. Si no usa el punto, entonces my_summary no tiene ningún argumento y devuelve un error que nos dice que argument &quot;dat&quot; está perdido. Puede ver el error escribiendo: heights %&gt;% group_by(sex) %&gt;% do(my_summary()) Si no usa el paréntesis, entonces la función no se ejecuta y en su lugar do intenta devolver la función. Esto da un error porque do siempre debe devolver un marco de datos. Puede ver el error escribiendo: heights %&gt;% group_by(sex) %&gt;% do(my_summary) 4.13 El paquete purrr En la sección 3.5 aprendimos sobre el sapply función, que nos permitió aplicar la misma función a cada elemento de un vector. Construimos una función y utilizamos sapply para calcular la suma de la primera n enteros para varios valores de n me gusta esto: compute_s_n &lt;- function(n){ x &lt;- 1:n sum(x) } n &lt;- 1:25 s_n &lt;- sapply(n, compute_s_n) Este tipo de operación, que aplica la misma función o procedimiento a elementos de un objeto, es bastante común en el análisis de datos. El paquete purrr incluye funciones similares a sapply pero eso interactúa mejor con otras funciones tidyverse. La principal ventaja es que podemos controlar mejor el tipo de funciones de salida. A diferencia de, sapply puede devolver varios tipos de objetos diferentes; por ejemplo, podríamos esperar un resultado numérico de una línea de código, pero sapply podría convertir nuestro resultado en carácter en algunas circunstancias. Las funciones purrr nunca harán esto: devolverán objetos de un tipo específico o devolverán un error si esto no es posible. La primera función purrr que aprenderemos es map, que funciona muy similar a sapply pero siempre, sin excepción, devuelve una lista: library(purrr) s_n &lt;- map(n, compute_s_n) class(s_n) #&gt; [1] &quot;list&quot; Si queremos un vector numérico, podemos usar map_dbl que siempre devuelve un vector de valores numéricos. s_n &lt;- map_dbl(n, compute_s_n) class(s_n) #&gt; [1] &quot;numeric&quot; Esto produce los mismos resultados que el sapply llamada que se muestra arriba. Una función purrr particularmente útil para interactuar con el resto del tidyverse es map_df, que siempre devuelve un marco de datos tibble. Sin embargo, la función que se llama debe devolver un vector o una lista con nombres. Por esta razón, el siguiente código daría como resultado un Argument 1 must have names error: s_n &lt;- map_df(n, compute_s_n) Necesitamos cambiar la función para que esto funcione: compute_s_n &lt;- function(n){ x &lt;- 1:n tibble(sum = sum(x)) } s_n &lt;- map_df(n, compute_s_n) El paquete purrr proporciona mucha más funcionalidad no cubierta aquí. Para obtener más detalles, puede consultar [este recurso en línea] (https://jennybc.github.io/purrr-tutorial/). 4.14 Tidyverse condicionales Un análisis de datos típico a menudo implicará una o más operaciones condicionales. En la sección 3.1 describimos el ifelse función, que utilizaremos ampliamente en este libro. En esta sección presentamos dos funciones dplyr que proporcionan una funcionalidad adicional para realizar operaciones condicionales. 4.14.1 case_when Los case_when la función es útil para vectorizar declaraciones condicionales. Esto es similar a ifelse pero puede generar cualquier cantidad de valores, en lugar de solo TRUE o FALSE. Aquí hay un ejemplo que divide los números en negativo, positivo y 0: x &lt;- c(-2, -1, 0, 1, 2) case_when(x &lt; 0 ~ &quot;Negative&quot;, x &gt; 0 ~ &quot;Positive&quot;, TRUE ~ &quot;Zero&quot;) #&gt; [1] &quot;Negative&quot; &quot;Negative&quot; &quot;Zero&quot; &quot;Positive&quot; &quot;Positive&quot; Un uso común de esta función es definir variables categóricas basadas en variables existentes. Por ejemplo, supongamos que queremos comparar las tasas de homicidios en tres grupos de estados: Nueva Inglaterra, West Coast, South_y_other. Para cada estado, debemos preguntar si está en Nueva Inglaterra, si no es así, preguntamos si está en la costa oeste, si no, preguntamos si está en el sur, y si no, asignamos otros. Así es como usamos case_when para hacer esto: murders %&gt;% mutate(group = case_when( abb %in% c(&quot;ME&quot;, &quot;NH&quot;, &quot;VT&quot;, &quot;MA&quot;, &quot;RI&quot;, &quot;CT&quot;) ~ &quot;New England&quot;, abb %in% c(&quot;WA&quot;, &quot;OR&quot;, &quot;CA&quot;) ~ &quot;West Coast&quot;, region == &quot;South&quot; ~ &quot;South&quot;, TRUE ~ &quot;Other&quot;)) %&gt;% group_by(group) %&gt;% summarize(rate = sum(total)/ sum(population) * 10^5) #&gt; # A tibble: 4 x 2 #&gt; group rate #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 New England 1.72 #&gt; 2 Other 2.71 #&gt; 3 South 3.63 #&gt; 4 West Coast 2.90 4.14.2 between Una operación común en el análisis de datos es determinar si un valor cae dentro de un intervalo. Podemos verificar esto usando condicionales. Por ejemplo para verificar si los elementos de un vector x están entre a y b podemos escribir x &gt;= a &amp; x &lt;= b Sin embargo, esto puede volverse engorroso, especialmente dentro del enfoque tidyverse. los between la función realiza la misma operación. between(x, a, b) 4.15 Ejercicios 1. Carga el murders conjunto de datos ¿Cual de los siguientes es verdadero? murders está en formato ordenado y se almacena en un tibble. si. murders está en formato ordenado y se almacena en un marco de datos. murders no está en formato ordenado y se almacena en un tibble. re. murders no está en formato ordenado y se almacena en un marco de datos. 2. Utilizar as_tibble para convertir el murders tabla de datos en un tibble y guárdelo en un objeto llamado murders_tibble. 3. Utilizar el group_by función para convertir asesinatos en un tibble que se agrupa por región. 4. Escriba el código tidyverse que sea equivalente a este código: exp(mean(log(murders$population))) Escríbalo usando la tubería para que cada función se llame sin argumentos. Use el operador de puntos para acceder a la población. Sugerencia: el código debe comenzar con murders %&gt;%. 5. Utilizar el map_df para crear un marco de datos con tres columnas llamadas n, s_n y s_n_2. La primera columna debe contener los números del 1 al 100. La segunda y la tercera columna deben contener la suma del 1 al 100 \\(n\\) con \\(n\\) el número de fila. "],
["importing-data.html", "Capítulo 5 Importando datos 5.1 Rutas y el directorio de trabajo 5.2 Los paquetes readr y readxl 5.3 Ejercicios 5.4 Descargando archivos 5.5 Funciones de importación de base R 5.6 Texto versus archivos binarios 5.7 Unicode versus ASCII 5.8 Organizando datos con hojas de cálculo 5.9 Ejercicios", " Capítulo 5 Importando datos Hemos estado usando conjuntos de datos ya almacenados como objetos R. Un científico de datos rara vez tendrá tanta suerte y tendrá que importar datos a R desde un archivo, una base de datos u otras fuentes. Actualmente, una de las formas más comunes de almacenar y compartir datos para el análisis es a través de hojas de cálculo electrónicas. Una hoja de cálculo almacena datos en filas y columnas. Básicamente es una versión de archivo de un marco de datos. Al guardar dicha tabla en un archivo de computadora, uno necesita una manera de definir cuándo termina una nueva fila o columna y comienza la otra. Esto a su vez define las celdas en las que se almacenan los valores individuales. Al crear hojas de cálculo con archivos de texto, como los creados con un editor de texto simple, se define una nueva fila con retorno y las columnas se separan con un carácter especial predefinido. Los caracteres más comunes son coma ( ,), punto y coma ( ;), espacio () y pestaña (un número predeterminado de espacios o \\t) Aquí hay un ejemplo de cómo se ve un archivo separado por comas si lo abrimos con un editor de texto básico: La primera fila contiene nombres de columna en lugar de datos. Llamamos a esto un encabezado, y cuando leemos datos de una hoja de cálculo es importante saber si el archivo tiene un encabezado o no. La mayoría de las funciones de lectura asumen que hay un encabezado. Para saber si el archivo tiene un encabezado, es útil mirar el archivo antes de intentar leerlo. Esto se puede hacer con un editor de texto o con RStudio. En RStudio, podemos hacerlo abriendo el archivo en el editor o navegando a la ubicación del archivo, haciendo doble clic en el archivo y presionando Ver archivo. Sin embargo, no todos los archivos de hoja de cálculo están en formato de texto. Las Hojas de cálculo de Google, que se representan en un navegador, son un ejemplo. Otro ejemplo es el formato propietario utilizado por Microsoft Excel. No se pueden ver con un editor de texto. A pesar de esto, debido al uso generalizado del software Microsoft Excel, este formato es ampliamente utilizado. Comenzamos este capítulo describiendo la diferencia entre archivos de texto (ASCII), Unicode y binarios y cómo esto afecta la forma en que los importamos. Luego explicamos los conceptos de rutas de archivos y directorios de trabajo, que son esenciales para comprender cómo importar datos de manera efectiva. Luego presentamos el paquete __readr__yreadxl y las funciones disponibles para importar hojas de cálculo en R. Finalmente, ofrecemos algunas recomendaciones sobre cómo almacenar y organizar datos en archivos. Los desafíos más complejos, como la extracción de datos de páginas web o documentos PDF, quedan para la parte del Libro de disputas de datos. 5.1 Rutas y el directorio de trabajo El primer paso al importar datos desde una hoja de cálculo es ubicar el archivo que contiene los datos. Aunque no lo recomendamos, puede utilizar un enfoque similar al que hace para abrir archivos en Microsoft Excel haciendo clic en el menú “Archivo” de RStudio, haciendo clic en “Importar conjunto de datos” y luego haciendo clic en las carpetas hasta encontrar el archivo. Queremos poder escribir código en lugar de utilizar el enfoque de apuntar y hacer clic. Las claves y los conceptos que necesitamos para aprender a hacer esto se describen en detalle en la parte de Herramientas de productividad de este libro. Aquí proporcionamos una descripción general de los conceptos básicos. El principal desafío en este primer paso es que debemos dejar que las funciones R que realizan la importación sepan dónde buscar el archivo que contiene los datos. La forma más sencilla de hacerlo es tener una copia del archivo en la carpeta en la que se ven las funciones de importación de forma predeterminada. Una vez que hacemos esto, todo lo que tenemos que proporcionar a la función de importación es el nombre del archivo. Se incluye una hoja de cálculo que contiene los datos de asesinatos de los EE. UU. Como parte del paquete dslabs. Encontrar este archivo no es sencillo, pero las siguientes líneas de código copian el archivo a la carpeta en la que R busca de forma predeterminada. Explicamos cómo funcionan estas líneas a continuación. filename &lt;- &quot;murders.csv&quot; dir &lt;- system.file(&quot;extdata&quot;, package = &quot;dslabs&quot;) fullpath &lt;- file.path(dir, filename) file.copy(fullpath, &quot;murders.csv&quot;) Este código no lee los datos en R, solo copia un archivo. Pero una vez que se copia el archivo, podemos importar los datos con una simple línea de código. Aquí usamos el read_csv función del paquete readr, que forma parte del tidyverse. library(tidyverse) dat &lt;- read_csv(filename) Los datos se importan y almacenan en dat. El resto de esta sección define algunos conceptos importantes y proporciona una visión general de cómo escribimos código que le dice a R cómo encontrar los archivos que queremos importar. Capítulo ?? proporciona más detalles sobre este tema. 5.1.1 El sistema de archivos Puede pensar en el sistema de archivos de su computadora como una serie de carpetas anidadas, cada una con otras carpetas y archivos. Los científicos de datos se refieren a las carpetas como directorios. Nos referimos a la carpeta que contiene todas las demás carpetas como el directorio raíz. Nos referimos al directorio en el que estamos ubicados actualmente como el directorio de trabajo. Por lo tanto, el directorio de trabajo cambia a medida que se mueve por las carpetas: considérelo como su ubicación actual. 5.1.2 Caminos relativos y completos El path de un archivo es una lista de nombres de directorios que pueden considerarse como instrucciones sobre qué carpetas hacer clic y en qué orden encontrar el archivo. Si estas instrucciones son para encontrar el archivo desde el directorio raíz, nos referiremos a él como la ruta completa. Si las instrucciones son para encontrar el archivo que comienza en el directorio de trabajo, nos referimos a él como una ruta relativa. Sección ?? proporciona más detalles sobre este tema. Para ver un ejemplo de una ruta completa en su sistema, escriba lo siguiente: system.file(package = &quot;dslabs&quot;) Las cadenas separadas por barras son los nombres de directorio. La primera barra diagonal representa el directorio raíz y sabemos que esta es una ruta completa porque comienza con una barra diagonal. Si el primer nombre del directorio aparece sin una barra diagonal al frente, entonces se supone que la ruta es relativa. Podemos usar la función list.files para ver ejemplos de caminos relativos. dir &lt;- system.file(package = &quot;dslabs&quot;) list.files(path = dir) #&gt; [1] &quot;data&quot; &quot;DESCRIPTION&quot; &quot;extdata&quot; &quot;help&quot; #&gt; [5] &quot;html&quot; &quot;INDEX&quot; &quot;Meta&quot; &quot;NAMESPACE&quot; #&gt; [9] &quot;R&quot; &quot;script&quot; Estas rutas relativas nos dan la ubicación de los archivos o directorios si comenzamos en el directorio con la ruta completa. Por ejemplo, la ruta completa a la help directorio en el ejemplo anterior es /Library/Frameworks/R.framework/Versions/3.5/Resources/library/dslabs/help. Nota: Probablemente no harás mucho uso del system.file funcionar en su trabajo de análisis de datos del día a día. Lo presentamos en esta sección porque facilita el intercambio de hojas de cálculo al incluirlas en el paquete dslabs. Raramente tendrá el lujo de incluir datos en paquetes que ya ha instalado. Sin embargo, con frecuencia necesitará navegar por rutas completas y relativas e importar datos con formato de hoja de cálculo. 5.1.3 El directorio de trabajo Recomendamos encarecidamente escribir solo rutas relativas en su código. La razón es que las rutas completas son exclusivas de su computadora y desea que su código sea portátil. Puede obtener la ruta completa de su directorio de trabajo sin escribir explícitamente utilizando getwd función. wd &lt;- getwd() Si necesita cambiar su directorio de trabajo, puede usar la función setwd o puede cambiarlo a través de RStudio haciendo clic en “Sesión”. 5.1.4 Generando nombres de ruta Otro ejemplo de obtener una ruta completa sin escribir explícitamente se dio arriba cuando creamos el objeto fullpath me gusta esto: filename &lt;- &quot;murders.csv&quot; dir &lt;- system.file(&quot;extdata&quot;, package = &quot;dslabs&quot;) fullpath &lt;- file.path(dir, filename) La función system.file proporciona la ruta completa de la carpeta que contiene todos los archivos y directorios relevantes para el paquete especificado por el package argumento. Al explorar los directorios en dir nos encontramos con que el extdata contiene el archivo que queremos: dir &lt;- system.file(package = &quot;dslabs&quot;) filename %in% list.files(file.path(dir, &quot;extdata&quot;)) #&gt; [1] TRUE Los system.file la función nos permite proporcionar un subdirectorio como primer argumento, para que podamos obtener la ruta completa de extdata directorio como este: dir &lt;- system.file(&quot;extdata&quot;, package = &quot;dslabs&quot;) La función file.path se usa para combinar nombres de directorio para producir la ruta completa del archivo que queremos importar. fullpath &lt;- file.path(dir, filename) 5.1.5 Copiando archivos usando rutas La última línea de código que usamos para copiar el archivo en nuestro directorio de inicio la función file.copy. Esta función toma dos argumentos: el archivo para copiar y el nombre para asignarlo en el nuevo directorio. file.copy(fullpath, &quot;murders.csv&quot;) #&gt; [1] TRUE Si un archivo se copia correctamente, el file.copy la función vuelve TRUE. Tenga en cuenta que le estamos dando al archivo el mismo nombre, murders.csv, pero podríamos haberle dado cualquier nombre. También tenga en cuenta que al no iniciar la cadena con una barra diagonal, R asume que esta es una ruta relativa y copia el archivo al directorio de trabajo. Debería poder ver el archivo en su directorio de trabajo y puede verificarlo usando: list.files() 5.2 Los paquetes readr y readxl En esta sección presentamos las principales funciones de importación de datos tidyverse. Utilizaremos el murders.csv archivo proporcionado por el paquete dslabs como ejemplo. Para simplificar la ilustración, copiaremos el archivo a nuestro directorio de trabajo usando el siguiente código: filename &lt;- &quot;murders.csv&quot; dir &lt;- system.file(&quot;extdata&quot;, package = &quot;dslabs&quot;) fullpath &lt;- file.path(dir, filename) file.copy(fullpath, &quot;murders.csv&quot;) 5.2.1 lector La biblioteca readr incluye funciones para leer datos almacenados en hojas de cálculo de archivos de texto en R. __readr__es parte del paquetetidyverse, o puede cargarlo directamente: library(readr) Las siguientes funciones están disponibles para leer hojas de cálculo: El Función Formato el read_table valores separados por espacios en blanco el read_csv valores separados por comas el read_csv2 valores separados por punto y coma el read_tsv valores separados delimitados por tabulaciones el read_delim formato de archivo de texto general, debe definir delimitador Aunque el sufijo generalmente nos dice qué tipo de archivo es, no hay garantía de que siempre coincidan. Podemos abrir el archivo para echar un vistazo o usar la función read_lines para mirar algunas líneas: read_lines(&quot;murders.csv&quot;, n_max = 3) #&gt; [1] &quot;state,abb,region,population,total&quot; #&gt; [2] &quot;Alabama,AL,South,4779736,135&quot; #&gt; [3] &quot;Alaska,AK,West,710231,19&quot; Esto también muestra que hay un encabezado. Ahora estamos listos para leer los datos en R. Del sufijo .csv y el vistazo al archivo, sabemos usar read_csv: dat &lt;- read_csv(filename) #&gt; Parsed with column specification: #&gt; cols( #&gt; state = col_character(), #&gt; abb = col_character(), #&gt; region = col_character(), #&gt; population = col_double(), #&gt; total = col_double() #&gt; ) Tenga en cuenta que recibimos un mensaje que nos informa qué tipos de datos se utilizaron para cada columna. También tenga en cuenta que dat es un tibble, no solo un marco de datos. Esto es porque read_csv es un analizador tidyverse. Podemos confirmar que los datos se han leído de hecho con: View(dat) Finalmente, tenga en cuenta que también podemos usar la ruta completa para el archivo: dat &lt;- read_csv(fullpath) 5.2.2 readxl Puede cargar el paquete readxl usando library(readxl) El paquete proporciona funciones para leer en formatos de Microsoft Excel: El Función Formato el read_excel detectar automáticamente el formato el read_xls formato original el read_xlsx nuevo formato Los formatos de Microsoft Excel le permiten tener más de una hoja de cálculo en un archivo. Estos se conocen como hojas. Las funciones enumeradas anteriormente leen la primera hoja por defecto, pero también podemos leer las otras. los excel_sheets la función nos da los nombres de todas las hojas en un archivo de Excel. Estos nombres se pueden pasar a sheet argumento en las tres funciones anteriores para leer hojas distintas de la primera. 5.3 Ejercicios 1. Utilizar el read_csv función para leer cada uno de los archivos que guarda el siguiente código en el files objeto: path &lt;- system.file(&quot;extdata&quot;, package = &quot;dslabs&quot;) files &lt;- list.files(path) files 2. Tenga en cuenta que el último, el olive archivo, nos da una advertencia. Esto se debe a que a la primera línea del archivo le falta el encabezado de la primera columna. Lea el archivo de ayuda para read_csv para descubrir cómo leer el archivo sin leer este encabezado. Si omite el encabezado, no debería recibir esta advertencia. Guarde el resultado en un objeto llamado dat. 3. Un problema con el enfoque anterior es que no sabemos qué representan las columnas. Tipo: names(dat) para ver que los nombres no son informativos. Utilizar el readLines función para leer solo en la primera línea (luego aprendemos cómo extraer valores de la salida). 5.4 Descargando archivos Otro lugar común para residir los datos es en Internet. Cuando estos datos están en archivos, podemos descargarlos y luego importarlos o incluso leerlos directamente desde la web. Por ejemplo, notamos que debido a que nuestro paquete dslabs está en GitHub, el archivo que descargamos con el paquete tiene una URL: url &lt;- &quot;https://raw.githubusercontent.com/rafalab/dslabs/master/inst/ extdata/murders.csv&quot; Los read_csv el archivo puede leer estos archivos directamente: dat &lt;- read_csv(url) Si desea tener una copia local del archivo, puede usar el download.file función: download.file(url, &quot;murders.csv&quot;) Esto descargará el archivo y lo guardará en su sistema con el nombre murders.csv. Puedes usar cualquier nombre aquí, no necesariamente murders.csv. Tenga en cuenta que al usar download.file debe tener cuidado ya que sobrescribirá los archivos existentes sin previo aviso. Dos funciones que a veces son útiles al descargar datos de Internet son tempdir y tempfile. El primero crea un directorio con un nombre aleatorio que es muy probable que sea único. Similar, tempfile crea una cadena de caracteres, no un archivo, que probablemente sea un nombre de archivo único. Entonces puede ejecutar un comando como este que borra el archivo temporal una vez que importa los datos: tmp_filename &lt;- tempfile() download.file(url, tmp_filename) dat &lt;- read_csv(tmp_filename) file.remove(tmp_filename) 5.5 Funciones de importación de base R R-base también proporciona funciones de importación. Estos tienen nombres similares a los del tidyverse, por ejemplo read.table, read.csv y read.delim. Sin embargo, hay un par de diferencias importantes. Para mostrar esto, leemos los datos con una función R-base: dat2 &lt;- read.csv(filename) Una diferencia importante es que los caracteres se convierten en factores: class(dat2$abb) #&gt; [1] &quot;factor&quot; class(dat2$region) #&gt; [1] &quot;factor&quot; Esto se puede evitar estableciendo el argumento stringsAsFactors a FALSE. dat &lt;- read.csv(&quot;murders.csv&quot;, stringsAsFactors = FALSE) class(dat$state) #&gt; [1] &quot;character&quot; En nuestra experiencia, esto puede ser motivo de confusión ya que una variable que se guardó como caracteres en el archivo se convierte en factores independientemente de lo que represente la variable. De hecho, recomendamos configurar stringsAsFactors=FALSE ser su enfoque predeterminado al usar los analizadores R-base. Puede convertir fácilmente las columnas deseadas en factores después de importar datos. 5.5.1 scan Al leer en hojas de cálculo, muchas cosas pueden salir mal. El archivo puede tener un encabezado multilínea, faltar celdas o puede usar una codificación inesperada15. Le recomendamos que lea esta publicación sobre problemas comunes que se encuentran aquí: [https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about -unicode-and-character-sets-no-excuses/] (https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know -about-unicode-and-character-sets-no-excuses/). Con experiencia, aprenderá a lidiar con diferentes desafíos. Sería útil leer detenidamente los archivos de ayuda para las funciones discutidas aquí. Otras dos funciones que son útiles son scan. Con el escaneo puede leer cada celda de un archivo. Aquí hay un ejemplo: path &lt;- system.file(&quot;extdata&quot;, package = &quot;dslabs&quot;) filename &lt;- &quot;murders.csv&quot; x &lt;- scan(file.path(path, filename), sep=&quot;,&quot;, what = &quot;c&quot;) x[1:10] #&gt; [1] &quot;state&quot; &quot;abb&quot; &quot;region&quot; &quot;population&quot; &quot;total&quot; #&gt; [6] &quot;Alabama&quot; &quot;AL&quot; &quot;South&quot; &quot;4779736&quot; &quot;135&quot; Tenga en cuenta que el tidyverse proporciona read_lines, una función igualmente útil. 5.6 Texto versus archivos binarios Para fines de ciencia de datos, los archivos generalmente se pueden clasificar en dos categorías: archivos de texto (también conocidos como archivos ASCII) y archivos binarios. Ya has trabajado con archivos de texto. Todos sus scripts R son archivos de texto y también los archivos R markdown utilizados para crear este libro. Las tablas csv que ha leído también son archivos de texto. Una gran ventaja de estos archivos es que podemos “mirarlos” fácilmente sin tener que comprar ningún tipo de software especial o seguir instrucciones complicadas. Se puede usar cualquier editor de texto para examinar un archivo de texto, incluidos los editores disponibles gratuitamente como RStudio, Notepad, textEdit, vi, emacs, nano y pico. Para ver esto, intente abrir un archivo csv con la herramienta RStudio “Abrir archivo”. Debería poder ver el contenido directamente en su editor. Sin embargo, si intenta abrir, digamos, un archivo Excel xls, jpg o png, no podrá ver nada inmediatamente útil. Estos son archivos binarios. Los archivos de Excel son en realidad carpetas comprimidas con varios archivos de texto dentro. Pero la principal distinción aquí es que los archivos de texto se pueden examinar fácilmente. Aunque R incluye herramientas para leer archivos binarios ampliamente utilizados, como archivos xls, en general querrá encontrar conjuntos de datos almacenados en archivos de texto. Del mismo modo, al compartir datos, desea que estén disponibles como archivos de texto siempre que el almacenamiento no sea un problema (los archivos binarios son mucho más eficientes para ahorrar espacio en su disco). En general, los formatos de texto sin formato facilitan el intercambio de datos, ya que no se requiere software comercial para trabajar con los datos. Extraer datos de una hoja de cálculo almacenada como un archivo de texto es quizás la forma más fácil de llevar datos de un archivo a una sesión R. Desafortunadamente, las hojas de cálculo no siempre están disponibles y el hecho de que pueda ver los archivos de texto no implica necesariamente que extraer datos de ellos sea sencillo. En la parte del Libro de disputas de datos, aprendemos a extraer datos de archivos de texto más complejos, como los archivos html. 5.7 Unicode versus ASCII Una trampa en la ciencia de datos es asumir que un archivo es un archivo de texto ASCII cuando, de hecho, es algo más que puede parecerse mucho a un archivo de texto ASCII: un archivo de texto Unicode. Para comprender la diferencia entre estos, recuerde que todo en una computadora necesita convertirse eventualmente en 0s y 1s. ASCII es una codificación que asigna caracteres a números. ASCII usa 7 bits (0s y 1s) lo que resulta en \\(2^7 = 128\\) elementos únicos, suficientes para codificar todos los caracteres en un teclado en inglés. Sin embargo, otros idiomas usan caracteres no incluidos en esta codificación. Por ejemplo, el é en México no está codificado por ASCII. Por esta razón, se definió una nueva codificación, que utiliza más de 7 bits: Unicode. Cuando se utiliza Unicode, se puede elegir entre 8, 16 y 32 bits abreviados UTF-8, UTF-16 y UTF-32 respectivamente. RStudio en realidad usa la codificación UTF-8. Aunque no vamos a entrar en detalles sobre cómo lidiar con las diferentes codificaciones aquí, es importante que sepa que existen diferentes codificaciones para que pueda diagnosticar mejor un problema si lo encuentra. Una forma en que se manifiestan los problemas es cuando ves personajes de “aspecto extraño” que no esperabas. Esta discusión de StackOverflow es un ejemplo: [https://stackoverflow.com/questions/18789330/r-on-windows-character-encoding-hellfont&gt;(https://stackoverflow.com/questions/18789330/r-on-windows -cadena de codificación de caracteres). 5.8 Organizando datos con hojas de cálculo Aunque hay paquetes R diseñados para leer este formato, si elige un formato de archivo para guardar sus propios datos, generalmente desea evitar Microsoft Excel. Recomendamos Google Sheets como una herramienta de software gratuita para organizar datos. Proporcionamos más recomendaciones en la sección Organización de datos con hojas de cálculo. Este libro se centra en el análisis de datos. Sin embargo, a menudo un científico de datos necesita recopilar datos o trabajar con otros que recopilan datos. Completar una hoja de cálculo a mano es una práctica que desaconsejamos y, en cambio, recomendamos que el proceso se automatice lo más posible. Pero a veces solo tienes que hacerlo. En esta sección, proporcionamos recomendaciones sobre cómo almacenar datos en una hoja de cálculo. Resumimos un artículo de Karl Broman y Kara Woo16. A continuación se encuentran sus recomendaciones generales. Por favor lea el periódico para detalles importantes. Sea coherente - Antes de comenzar a ingresar datos, tenga un plan. Una vez que tenga un plan, sea consistente y sígalo. Elija buenos nombres para las cosas: desea que los nombres que elija para los objetos, archivos y directorios sean memorables, fáciles de deletrear y descriptivos. Esto es realmente un equilibrio difícil de lograr y requiere tiempo y reflexión. Una regla importante a seguir es no use espacios, use guiones bajos _ o guiones en su lugar -. Además, evite los símbolos; atenerse a letras y números. Escribir fechas como AAAA-MM-DD - Para evitar confusiones, recomendamos encarecidamente utilizar este estándar global ISO 8601. No Celdas vacías - Complete todas las celdas y use un código común para los datos faltantes. Ponga solo una cosa en una celda - Es mejor agregar columnas para almacenar la información adicional en lugar de tener más de una pieza de información en una celda. Hazlo un rectángulo - La hoja de cálculo debe ser un rectángulo. Crear un diccionario de datos - Si necesita explicar cosas, como cuáles son las columnas o cuáles son las etiquetas utilizadas para las variables categóricas, hágalo en un archivo separado. Sin cálculos en los archivos de datos sin procesar - Excel le permite realizar cálculos. No hagas esta parte de tu hoja de cálculo. El código para los cálculos debe estar en un script. No use color de fuente o resaltado como datos - La mayoría de las funciones de importación no pueden importar esta información. Codifique esta información como una variable en su lugar. Hacer copias de seguridad: realice copias de seguridad periódicas de sus datos. Utilice la validación de datos para evitar errores - Aproveche las herramientas en su software de hoja de cálculo para que el proceso sea lo más libre de errores y repetitivo-libre de estrés posible. Guardar los datos como archivos de texto - Guarde los archivos para compartir en formato delimitado por comas o tabulaciones. 5.9 Ejercicios 1. Elija una medida que pueda tomar de forma regular. Por ejemplo, su peso diario o cuánto tiempo le lleva correr 5 millas. Mantenga una hoja de cálculo que incluya la fecha, la hora, la medición y cualquier otra variable informativa que considere valiosa. Haz esto por 2 semanas. Luego haz una trama. https://en.wikipedia.org/wiki/Character_encoding↩ https://www.tandfonline.com/doi/abs/10.1080/00031305.2017.1375989↩ "]
]
