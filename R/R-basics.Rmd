# (PART) R {-}

# R básicos {#r-basics}

```{r, echo=FALSE}
img_path <- "R/img"
```

En este libro, utilizaremos el entorno de software R para todos nuestros
análisis. Aprenderá R y técnicas de análisis de datos simultáneamente. Para seguir, por lo tanto, necesitará acceso a R. También recomendamos el uso de un _entorno de desarrollo integrado_ (IDE), como RStudio, para guardar su trabajo.
Tenga en cuenta que es común que un curso o taller ofrezca acceso a un entorno R y un IDE a través de su navegador web, como lo hace RStudio cloud^[https://rstudio.cloud]. Si tiene acceso a dicho recurso, no necesita instalar R y RStudio. Sin embargo, si tiene la intención de convertirse en un analista de datos avanzado, recomendamos instalar estas herramientas en su computadora^[https://rafalab.github.io/dsbook/installing-r-rstudio.html].
Tanto R como RStudio son gratuitos y están disponibles en línea.

## Estudio de caso: asesinatos de armas

Imagine que vive en Europa y se le ofrece un trabajo en una empresa estadounidense con muchas ubicaciones en todos los estados. Es un gran trabajo, pero noticias con titulares como ** Tasa de homicidios con armas de fuego de EE. UU. Más alta que otros países desarrollados **^[http://abcnews.go.com/blogs/headlines/2012/12/us-gun-ownership -homicide-rate-superior-que-otros-países-desarrollados/] ¿te preocupa? Gráficos como este pueden preocuparte aún más:


```{r murder-rate-example-1, echo=FALSE, warning=FALSE, message=FALSE, out.width="70%"}
##from http://abcnews.go.com/images/International/homocides_g8_countries_640x360_wmain.jpg
##knitr::include_graphics(file.path(img_path,"homocides_g8_countries_640x360_wmain.jpg"))
library(tidyverse)
library(ggplot2)
library(ggflags)
library(countrycode)

dat <- tibble(country = toupper(c("US", "Italy", "Canada", "UK", "Japan", "Germany", "France", "Russia")),
count = c(3.2, 0.71, 0.5, 0.1, 0, 0.2, 0.1, 0),
label = c(as.character(c(3.2, 0.71, 0.5, 0.1, 0, 0.2, 0.1)), "No Data"),
code = c("us", "it", "ca", "gb", "jp", "de", "fr", "ru"))


dat %>%
mutate(country = reorder(country, -count)) %>%
ggplot(aes(country, count, label = label)) +
geom_bar(stat = "identity", fill = "darkred") +
geom_text(nudge_y = 0.2, color = "darkred", size = 5) +
geom_flag(y = -.5, aes(country = code), size = 12) +
scale_y_continuous(breaks = c(0, 1, 2, 3, 4), limits = c(0,4)) +
geom_text(aes(6.25, 3.8, label="Source UNODC Homicide Statistics")) +
ggtitle(toupper("Homicide Per 100,000 in G-8 Countries")) +
xlab("") +
ylab("# of gun-related homicides\nper 100,000 people") +
ggthemes::theme_economist() +
theme(axis.text.x = element_text(size = 8, vjust = -12),
axis.ticks.x=element_blank(),
axis.line.x = element_blank(),
plot.margin = unit(c(1,1,1,1), "cm"))
```

<!--(Source:
[Ma&#39;ayan Rosenzweigh/ ABC News] (https://abcnews.go.com/blogs/headlines/2012/12/us-gun-ownership-homicide-rate-higher-than-other-developed-countries/), Datos de las estadísticas de homicidios de la UNODC) ->


O peor aún, esta versión de [everytown.org] (https://everytownresearch.org):
```{r murder-rate-example-2, echo=FALSE, out.width="70%"}
# from https://everytownresearch.org/wp-content/uploads/2016/07/GunTrends_murders_per_1000.png
# knitr::include_graphics(file.path(img_path,"GunTrends_murders_per_1000.png"))

dat <- tibble(country = toupper(c("United States", "Canada", "Portugal", "Ireland", "Italy", "Belgium", "Finland", "France", "Netherlands", "Denmark", "Sweden", "Slovakia", "Austria", "New Zealand", "Australia", "Spain", "Czech Republic", "Hungary", "Germany", "United Kingdom", "Norway", "Japan", "Republic of Korea")),
count = c(3.61, 0.5, 0.48, 0.35, 0.35, 0.33, 0.26, 0.20, 0.20, 0.20, 0.19, 0.19, 0.18, 0.16, 0.16, 0.15, 0.12, 0.10, 0.06, 0.04, 0.04, 0.01, 0.01))

dat %>%
mutate(country = reorder(country, count)) %>%
ggplot(aes(country, count, label = count)) +
geom_bar(stat = "identity", fill = "darkred", width = 0.5) +
geom_text(nudge_y = 0.2, size = 3) +
xlab("") + ylab("") +
ggtitle(toupper("Gun Homicides per 100,000 residents")) +
theme_minimal() +
theme(panel.grid.major =element_blank(), panel.grid.minor = element_blank(),
axis.text.x = element_blank(),
axis.ticks.length = unit(-0.4, "cm")) +
coord_flip()
```

<!--(Source [everytown.org](https://everytownresearch.org))-->

Pero entonces recuerdas que Estados Unidos es un país grande y diverso con 50 estados muy diferentes, así como el Distrito de Columbia (DC).

```{r us-murders-by-state-map, message=FALSE, echo=FALSE}
library(tidyverse)
library(dslabs)

fifty_states <- map_data("state")
data(murders)
murders %>% mutate(murder_rate = total/population*10^5,
state = tolower(state),
colors= factor(ceiling(pmin(murder_rate, 9)))) %>%
ggplot(aes(map_id = state)) +
geom_map(aes(fill = colors), color = "black", map = fifty_states) +
expand_limits(x = fifty_states$long, y = fifty_states$lat) +
coord_map() +
scale_x_continuous(breaks = NULL) +
scale_y_continuous(breaks = NULL) +
labs(x = "", y = "") +
theme(panel.background = element_blank()) +
scale_fill_brewer(guide=FALSE) +
theme_minimal()
rm(fifty_states)
```


California, por ejemplo, tiene una población más grande que Canadá, y 20 estados de EE. UU. Tienen poblaciones más grandes que la de Noruega. En algunos aspectos, la variabilidad entre los estados de los EE. UU. Es similar a la variabilidad entre los países de Europa. Además, aunque no se incluye en los cuadros anteriores, las tasas de asesinatos en Lituania, Ucrania y Rusia son superiores a 4 por cada 100.000. Entonces, tal vez las noticias informan que te preocupa que seas demasiado superficial. Tiene opciones de dónde vivir y desea determinar la seguridad de cada estado en particular. Obtendremos algunas ideas al examinar datos relacionados con homicidios con armas de fuego en los EE. UU. Durante 2010 usando R.

Antes de comenzar con nuestro ejemplo, necesitamos cubrir la logística, así como algunos de los componentes básicos que se requieren para obtener habilidades de R más avanzadas. Tenga en cuenta que la utilidad de algunos de estos bloques de construcción puede no ser obvia de inmediato, pero más adelante en el libro apreciará haber dominado estas habilidades.

## Los muy básicos

Antes de comenzar con el motivador conjunto de datos, necesitamos cubrir los conceptos básicos de R.

### Objetos

Supongamos que un estudiante de secundaria nos pide ayuda para resolver varias ecuaciones cuadráticas de la forma $ax^2+bx+c = 0$. La fórmula cuadrática nos da las soluciones:

$$
\frac{-b - \sqrt{b^2 - 4ac}}{2a}\,\, \mbox{ and } \frac{-b + \sqrt{b^2 - 4ac}}{2a}
$$
que por supuesto cambian dependiendo de los valores de $a$, $b$ y $c$. Una ventaja de los lenguajes de programación es que podemos definir variables y escribir expresiones con estas variables, de forma similar a como lo hacemos en matemáticas, pero obtener una solución numérica. Escribiremos un código general para la ecuación cuadrática a continuación, pero si se nos pide resolver $x^2 + x -1 = 0$, luego definimos:

```{r}
a <- 1
b <- 1
c <- -1
```

que almacena los valores para su uso posterior. Usamos `<-` para asignar valores a las variables.

También podemos asignar valores usando `=` en lugar de `<-`, pero recomendamos no usar `=` para evitar confusión.

Copie y pegue el código anterior en su consola para definir las tres variables. Tenga en cuenta que R no imprime nada cuando hacemos esta asignación. Esto significa que los objetos se definieron con éxito. Si hubiera cometido un error, habría recibido un mensaje de error.

Para ver el valor almacenado en una variable, simplemente le pedimos a R que evalúe `a` y muestra el valor almacenado:

```{r}
a
```

Una forma más explícita de pedirle a R que nos muestre el valor almacenado en `a` esta usando `print` me gusta esto:

```{r}
print(a)
```

Usamos el término _objeto_ para describir cosas que están almacenadas en R. Las variables son ejemplos, pero los objetos también pueden ser entidades más complicadas como funciones, que se describen más adelante.



### El espacio de trabajo

A medida que definimos objetos en la consola, en realidad estamos cambiando el _workspace_. Puede ver todas las variables guardadas en su espacio de trabajo escribiendo:

```{r}
ls()
```

En RStudio, la pestaña _Environment_ muestra los valores:

```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"rstudio-environment.png"))
```

Deberíamos ver `a`, `b` y `c`. Si intenta recuperar el valor de una variable que no está en su espacio de trabajo, recibirá un error. Por ejemplo, si escribe `x` recibirás el siguiente mensaje: `Error: object 'x' not found`.

Ahora, dado que estos valores se guardan en variables, para obtener una solución a nuestra ecuación, utilizamos la fórmula cuadrática:

```{r}
(-b + sqrt(b^2 - 4*a*c) )/ ( 2*a )
(-b - sqrt(b^2 - 4*a*c) )/ ( 2*a )
```


### Funciones

Una vez que defina las variables, el proceso de análisis de datos generalmente se puede describir como una serie de _funciones_ aplicadas a los datos. R incluye varias funciones predefinidas y la mayoría de las líneas de análisis que construimos hacen un uso extensivo de ellas.

Ya usamos el `install.packages`, `library` y `ls` funciones También usamos la función `sqrt` para resolver la ecuación cuadrática de arriba. Hay muchas más funciones preconstruidas y aún más se pueden agregar a través de paquetes. Estas funciones no aparecen en el espacio de trabajo porque no las definió, pero están disponibles para su uso inmediato.

En general, necesitamos usar paréntesis para evaluar una función. Si escribes `ls`, la función no se evalúa y en su lugar R le muestra el código que define la función. Si escribes `ls()` la función se evalúa y, como se ve arriba, vemos objetos en el espacio de trabajo.

Diferente a `ls`, la mayoría de las funciones requieren uno o más _argumentos_. A continuación se muestra un ejemplo de cómo asignamos un objeto al argumento de la función `log`. Recuerda que anteriormente definimos `a` ser 1:

```{r}
log(8)
log(a)
```

Puede averiguar qué espera la función y qué hace revisando los manuales muy útiles incluidos en R. Puede obtener ayuda utilizando el `help` funciona así:

```{r, eval=FALSE}
help("log")
```

Para la mayoría de las funciones, también podemos usar esta abreviatura:

```{r, eval=FALSE}
?log
```

La página de ayuda le mostrará qué argumentos espera la función. Por ejemplo, `log` necesidades `x` y `base` correr. Sin embargo, algunos argumentos son obligatorios y otros son opcionales. Puede determinar qué argumentos son opcionales observando en el documento de ayuda que se asigna un valor predeterminado con `=`. Definir esto es opcional. Por ejemplo, la base de la función `log` por defecto es `base = exp(1)` haciendo `log` el registro natural por defecto.

Si desea echar un vistazo rápido a los argumentos sin abrir el sistema de ayuda, puede escribir:

```{r}
args(log)
```

Puede cambiar los valores predeterminados simplemente asignando otro objeto:

```{r}
log(8, base = 2)
```

Tenga en cuenta que no hemos estado especificando el argumento `x` como tal:
```{r}
log(x = 8, base = 2)
```

El código anterior funciona, pero podemos ahorrarnos algo de tipeo: si no se usa un nombre de argumento, R asume que está ingresando argumentos en el orden que se muestra en el archivo de ayuda o por `args`. Entonces, al no usar los nombres, se supone que los argumentos son `x` seguido por `base`:

```{r}
log(8,2)
```

Si usa los nombres de los argumentos, podemos incluirlos en el orden que queramos:

```{r}
log(base = 2, x = 8)
```

Para especificar argumentos, debemos usar `=` y no puede usar `<-`.

Hay algunas excepciones a la regla de que las funciones necesitan los paréntesis para ser evaluadas. Entre estos, los más utilizados son los operadores aritméticos y relacionales. Por ejemplo:

```{r}
2^3
```

Puede ver los operadores aritméticos escribiendo:

```{r, eval = TRUE}
help("+")
```

o

```{r, eval = TRUE}
?"+"
```

y los operadores relacionales escribiendo:

```{r, eval = TRUE}
help(">")
```

o

```{r}
?">"
```

### Otros objetos preconstruidos

Hay varios conjuntos de datos que se incluyen para que los usuarios practiquen y prueben funciones. Puede ver todos los conjuntos de datos disponibles escribiendo:

```{r}
data()
```

Esto le muestra el nombre del objeto para estos conjuntos de datos. Estos conjuntos de datos son objetos que se pueden usar simplemente escribiendo el nombre. Por ejemplo, si escribe:

```{r, eval=FALSE}
co2
```
R le mostrará los datos de concentración de CO2 atmosférico de Mauna Loa.

Otros objetos precompilados son cantidades matemáticas, como la constante $\pi$ y $\infty$:

```{r}
pi
Inf+1
```

### Nombres de variables

Hemos usado las letras `a`, `b` y `c` como nombres de variables, pero los nombres de variables pueden ser casi cualquier cosa. Algunas reglas básicas en R son que los nombres de variables tienen que comenzar con una letra, no pueden contener espacios y no deben ser variables predefinidas en R. Por ejemplo, no nombre una de sus variables `install.packages` escribiendo algo como
`install.packages <- 2`.

Una buena convención a seguir es usar palabras significativas que describan lo que está almacenado, usar solo minúsculas y usar guiones bajos como sustituto de espacios. Para las ecuaciones cuadráticas, podríamos usar algo como esto:

```{r}
solution_1 <- (-b + sqrt(b^2 - 4*a*c))/ (2*a)
solution_2 <- (-b - sqrt(b^2 - 4*a*c))/ (2*a)
```

Para obtener más consejos, recomendamos estudiar la guía de estilo de Hadley Wickham^[http://adv-r.had.co.nz/Style.html].

### Guardar su espacio de trabajo

Los valores permanecen en el espacio de trabajo hasta que finalice su sesión o los borre con la función `rm`. Pero los espacios de trabajo también se pueden guardar para su uso posterior. De hecho, cuando sale de R, el programa le pregunta si desea guardar su espacio de trabajo. Si lo guarda, la próxima vez que inicie R, el programa restaurará el espacio de trabajo.

En realidad, recomendamos no guardar el espacio de trabajo de esta manera porque, a medida que comience a trabajar en diferentes proyectos, será más difícil hacer un seguimiento de lo que se guarda. En su lugar, le recomendamos que asigne al espacio de trabajo un nombre específico. Puedes hacer esto usando la función `save` o `save.image`. Para cargar, use la función `load`. Al guardar un espacio de trabajo, recomendamos el sufijo `rda` o `RData`. En RStudio, también puede hacerlo navegando a la pestaña _Sesión_y eligiendo_Guardar espacio de trabajo como_. Luego puede cargarlo usando las opciones _Load Workspace_ en la misma pestaña.
Puedes leer las páginas de ayuda en `save`, `save.image` y `load` aprender más.


### Scripts motivadores

Para resolver otra ecuación como $3x^2 + 2x -1$, podemos copiar y pegar el código anterior y luego redefinir las variables y volver a calcular la solución:

```{r, eval=FALSE}
a <- 3
b <- 2
c <- -1
(-b + sqrt(b^2 - 4*a*c))/ (2*a)
(-b - sqrt(b^2 - 4*a*c))/ (2*a)
```

Al crear y guardar un script con el código anterior, no necesitaríamos volver a escribir todo cada vez y, en cambio, simplemente cambiar los nombres de las variables. Intente escribir la secuencia de comandos anterior en un editor y observe lo fácil que es cambiar las variables y recibir una respuesta.

### Comentando tu código

Si una línea de código R comienza con el símbolo `#`, no se evalúa Podemos usar esto para escribir recordatorios de por qué escribimos un código particular. Por ejemplo, en el script anterior, podríamos agregar:


```{r, eval=FALSE}
## Code to compute solution to quadratic equation of the form ax^2 + bx + c
## define the variables
a <- 3
b <- 2
c <- -1

## now compute the solution
(-b + sqrt(b^2 - 4*a*c))/ (2*a)
(-b - sqrt(b^2 - 4*a*c))/ (2*a)
```


## Ejercicios

1\. ¿Cuál es la suma de los primeros 100 enteros positivos? La fórmula para la suma de enteros. $1$ mediante $n$ es $n(n+1)/2$. Definir $n=100$ y luego usa R para calcular la suma de $1$ mediante $100$ usando la fórmula ¿Cuál es la suma?

2\. Ahora use la misma fórmula para calcular la suma de los enteros del 1 al 1,000.

3\. Mira el resultado de escribir el siguiente código en R:

```{r, eval=FALSE}
n <- 1000
x <- seq(1, n)
sum(x)
```

En función del resultado, ¿cuáles crees que son las funciones? `seq` y `sum` ¿hacer? Puedes usar `help`.

a. `sum` crea una lista de números y `seq` los suma
si. `seq` crea una lista de números y `sum` los suma
c. `seq` crea una lista aleatoria y `sum` calcula la suma de 1 a 1,000.
re. `sum` siempre devuelve el mismo número.

4\. En matemáticas y programación, decimos que evaluamos una función cuando reemplazamos el argumento con un número dado. Entonces si escribimos `sqrt(4)`, evaluamos el `sqrt` función. En R, puede evaluar una función dentro de otra función. Las evaluaciones suceden de adentro hacia afuera. Use una línea de código para calcular el registro, en base 10, de la raíz cuadrada de 100.


5\. ¿Cuál de los siguientes siempre devolverá el valor numérico almacenado en `x`? Puede probar ejemplos y usar el sistema de ayuda si lo desea.

a. `log(10^x)`
si. `log10(x^10)`
c. `log(exp(x))`
re. `exp(log(x, base = 2))`


## Tipos de datos

Las variables en R pueden ser de diferentes tipos. Por ejemplo, necesitamos distinguir números de cadenas de caracteres y tablas de listas simples de números. La función `class` nos ayuda a determinar qué tipo de objeto tenemos:

```{r}
a <- 2
class(a)
```

Para trabajar de manera eficiente en R, es importante aprender los diferentes tipos de variables y qué podemos hacer con ellas.

### Marcos de datos {#data-frames}

Hasta ahora, las variables que hemos definido son solo un número. Esto no es muy útil para almacenar datos. La forma más común de almacenar un conjunto de datos en R es en un marco de datos. Conceptualmente, podemos pensar en un marco de datos como una tabla con filas que representan observaciones y las diferentes variables informadas para cada observación que define las columnas. Los marcos de datos son particularmente útiles para conjuntos de datos porque podemos combinar diferentes tipos de datos en un solo objeto.

Una gran proporción de los desafíos del análisis de datos comienza con los datos almacenados en un marco de datos. Por ejemplo, almacenamos los datos para nuestro ejemplo motivador en un marco de datos. Puede acceder a este conjunto de datos cargando la biblioteca __dslabs__ y cargando `murders` conjunto de datos utilizando el `data` función:

```{r}
library(dslabs)
data(murders)
```

Para ver que esto es de hecho un marco de datos, escribimos:

```{r}
class(murders)
```

### Examinando un objeto

La función `str` es útil para obtener más información sobre la estructura de un objeto:

```{r, echo=FALSE}
# change str to make sure it stays within margins
str <- function(x) utils::str(x, strict.width = 'wrap')
```

```{r}
str(murders)
```

```{r, echo=FALSE}
# remove str we defiend
rm(str)
```

Esto nos dice mucho más sobre el objeto. Vemos que la tabla tiene 51 filas (50 estados más DC) y cinco variables. Podemos mostrar las primeras seis líneas usando la función `head`:

```{r}
head(murders)
```

En este conjunto de datos, cada estado se considera una observación y se informan cinco variables para cada estado.

Antes de continuar con la respuesta a nuestra pregunta original sobre los diferentes estados, aprendamos más sobre los componentes de este objeto.

### El descriptor de acceso: `$`

Para nuestro análisis, necesitaremos acceder a las diferentes variables representadas por columnas incluidas en este marco de datos. Para hacer esto, utilizamos el operador de acceso `$` de la siguiente manera:

```{r}
murders$population
```

¿Pero cómo supimos usar `population`? Anteriormente, aplicando la función `str` al objeto `murders`, revelamos los nombres de cada una de las cinco variables almacenadas en esta tabla. Podemos acceder rápidamente a los nombres de las variables usando:

```{r}
names(murders)
```

Es importante saber que el orden de las entradas en `murders$population` conserva el orden de las filas en nuestra tabla de datos. Esto luego nos permitirá manipular una variable basada en los resultados de otra. Por ejemplo, podremos ordenar los nombres de los estados por el número de asesinatos.

**Consejo**: R viene con una muy buena funcionalidad de autocompletar que nos ahorra la molestia de escribir todos los nombres. Intenta escribir `murders$p` luego presionando la tecla _tab_ en su teclado. Esta funcionalidad y muchas otras funciones útiles de autocompletar están disponibles cuando se trabaja en RStudio.

### Vectores: numéricos, caracteres y lógicos

El objeto `murders$population` no es un número sino varios. Llamamos a este tipo de objetos _vectores_. Un solo número es técnicamente un vector de longitud 1, pero en general usamos el término vectores para referirnos a objetos con varias entradas. La función `length` te dice cuántas entradas hay en el vector:

```{r}
pop <- murders$population
length(pop)
```

Este vector particular es _numeric_ ya que los tamaños de población son números:

```{r}
class(pop)
```
En un vector numérico, cada entrada debe ser un número.

Para almacenar cadenas de caracteres, los vectores también pueden ser de la clase _caracter_. Por ejemplo, los nombres de estado son caracteres:

```{r}
class(murders$state)
```

Al igual que con los vectores numéricos, todas las entradas en un vector de caracteres deben ser un carácter.

Otro tipo importante de vectores son los vectores lógicos. Estos deben ser `TRUE` o `FALSE`.

```{r}
z <- 3 == 2
z
class(z)
```

Aquí el `==` es un operador relacional que pregunta si 3 es igual a 2. En R, si solo usa uno `=`, en realidad asigna una variable, pero si usa dos `==` prueba para la igualdad.

Puede ver los otros operadores relacionales escribiendo:

```{r, eval=FALSE}
?Comparison
```

En secciones futuras, verá cuán útiles pueden ser los operadores relacionales.

Discutimos características más importantes de los vectores después del siguiente conjunto de ejercicios.


**Avanzado**: Matemáticamente, los valores en `pop` son enteros y hay una clase de enteros en R. Sin embargo, de manera predeterminada, a los números se les asigna una clase numérica incluso cuando son enteros redondos. Por ejemplo, `class(1)` devuelve numérico Puede convertirlos en un entero de clase con el `as.integer()` función o agregando un `L` me gusta esto: `1L`. Tenga en cuenta la clase escribiendo: `class(1L)`


### Factores {#factors}

En el `murders` conjunto de datos, podríamos esperar que la región también sea un vector de caracteres. Sin embargo, no es:

```{r}
class(murders$region)
```

Es un _factor_. Los factores son útiles para almacenar datos categóricos. Podemos ver que solo hay 4 regiones utilizando el `levels` función:


```{r}
levels(murders$region)
```

En el fondo, R almacena estos _niveles_ como enteros y mantiene un mapa para realizar un seguimiento de las etiquetas. Esto es más eficiente en memoria que almacenar todos los caracteres.

Tenga en cuenta que los niveles tienen un orden que es diferente del orden de aparición en el objeto factor. El valor predeterminado es que los niveles sigan el orden alfabético. Sin embargo, a menudo queremos que los niveles sigan un orden diferente. Veremos varios ejemplos de esto en la parte de visualización de datos del libro. La función `reorder` nos permite cambiar el orden de los niveles de una variable de factor en función de un resumen calculado en un vector numérico. Vamos a demostrar esto con un simple ejemplo.

Supongamos que queremos los niveles de la región por el número total de asesinatos en lugar de por orden alfabético. Si hay valores asociados con cada nivel, podemos usar el `reorder` y especifique un resumen de datos para determinar el orden. El siguiente código toma la suma del total de asesinatos en cada región y reordena el factor siguiendo estas sumas.

```{r}
region <- murders$region
value <- murders$total
region <- reorder(region, value, FUN = sum)
levels(region)
```

El nuevo orden está de acuerdo con el hecho de que el noreste tiene menos asesinatos y el sur tiene más.

**Advertencia**: los factores pueden ser una fuente de confusión, ya que a veces se comportan como personajes y otras no. Como resultado, los factores y caracteres confusos son una fuente común de errores.

### Listas

Los marcos de datos son un caso especial de _lists_. Cubriremos las listas con más detalle más adelante, pero sabemos que son útiles porque puede almacenar cualquier combinación de diferentes tipos. A continuación se muestra un ejemplo de una lista que creamos para usted:


```{r, echo=FALSE}
record <- list(name = "John Doe",
student_id = 1234,
grades = c(95, 82, 91, 97, 93),
final_grade = "A")
```

```{r}
record
class(record)
```

Al igual que con los marcos de datos, puede extraer los componentes de una lista con el descriptor de acceso `$`. De hecho, los marcos de datos son un tipo de lista.

```{r}
record$student_id
```

También podemos usar corchetes dobles ( `[[`) me gusta esto:

```{r}
record[["student_id"]]
```

Debería acostumbrarse al hecho de que en R, a menudo hay varias formas de hacer lo mismo, como acceder a las entradas.

También puede encontrar listas sin nombres de variables.

```{r, echo=FALSE}
record2 <- list("John Doe",
1234)
```

```{r}
record2
```

Si una lista no tiene nombres, no puede extraer los elementos con `$`, pero aún puede usar el método de corchetes y, en lugar de proporcionar el nombre de la variable, proporciona el índice de la lista, de esta manera:

```{r}
record2[[1]]
```


No usaremos listas hasta más tarde, pero puede encontrar uno en su propia exploración de R. Por esta razón, le mostramos algunos conceptos básicos aquí.


### Matrices {#matrices}

Las matrices son otro tipo de objeto que son comunes en R. Las matrices son similares a los marcos de datos en que son bidimensionales: tienen filas y columnas. Sin embargo, al igual que los vectores numéricos, de caracteres y lógicos, las entradas en matrices deben ser del mismo tipo. Por esta razón, los marcos de datos son mucho más útiles para almacenar datos, ya que podemos tener caracteres, factores y números en ellos.

Sin embargo, las matrices tienen una gran ventaja sobre los marcos de datos: podemos realizar operaciones de álgebra matricial, un poderoso tipo de técnica matemática. No describimos estas operaciones en este libro, pero gran parte de lo que sucede en segundo plano cuando realiza un análisis de datos involucra matrices. Cubrimos las matrices con más detalle en el Capítulo \@ref(matrix-algebra) pero descríbalos brevemente aquí, ya que algunas de las funciones que aprenderemos devuelven matrices.

Podemos definir una matriz usando el `matrix` función. Necesitamos especificar el número de filas y columnas.

```{r}
mat <- matrix(1:12, 4, 3)
mat
```

Puede acceder a entradas específicas en una matriz usando corchetes ( `[`) Si desea la segunda fila, tercera columna, usa:

```{r}
mat[2, 3]
```

Si desea toda la segunda fila, deje el lugar de la columna vacío:

```{r}
mat[2, ]
```

Tenga en cuenta que esto devuelve un vector, no una matriz.

Del mismo modo, si desea la tercera columna completa, deje el lugar de la fila vacío:

```{r}
mat[, 3]
```

Esto también es un vector, no una matriz.

Puede acceder a más de una columna o más de una fila si lo desea. Esto te dará una nueva matriz.

```{r}
mat[, 2:3]
```

Puede subconjuntar tanto filas como columnas:

```{r}
mat[1:2, 2:3]
```

Podemos convertir matrices en marcos de datos usando la función `as.data.frame`:

```{r}
as.data.frame(mat)
```

También puede usar corchetes individuales ( `[`) para acceder a filas y columnas de un marco de datos:

```{r}
data("murders")
murders[25, 1]
murders[2:3, ]
```


## Ejercicios

1\. Cargue el conjunto de datos de asesinatos de EE. UU.

```{r}
library(dslabs)
data(murders)
```

Usa la función `str` para examinar la estructura de la `murders` objeto. ¿Cuál de las siguientes opciones describe mejor las variables representadas en este marco de datos?

a. Los 51 estados.
si. Las tasas de asesinatos para los 50 estados y DC.
c. El nombre del estado, la abreviatura del nombre del estado, la región del estado y la población del estado y el número total de asesinatos para 2010.
re. `str` no muestra información relevante.

2\. ¿Cuáles son los nombres de columna utilizados por el marco de datos para estas cinco variables?

3\. Usa el descriptor de acceso `$` para extraer las abreviaturas de estado y asignarlas al objeto `a`. ¿Cuál es la clase de este objeto?

4\. Ahora use los corchetes para extraer las abreviaturas de estado y asignarlas al objeto `b`. Utilizar el `identical` función para determinar si `a` y `b` son lo mismo.

5\. Vimos que el `region` la columna almacena un factor. Puede corroborar esto escribiendo:

```{r, eval=FALSE}
class(murders$region)
```

Con una línea de código, use la función `levels` y `length` para determinar el número de regiones definidas por este conjunto de datos.

6\. La función `table` toma un vector y devuelve la frecuencia de cada elemento. Puede ver rápidamente cuántos estados hay en cada región aplicando esta función. Use esta función en una línea de código para crear una tabla de estados por región.

## Vectores

En R, los objetos más básicos disponibles para almacenar datos son _vectores_. Como hemos visto, los conjuntos de datos complejos generalmente se pueden dividir en componentes que son vectores. Por ejemplo, en un marco de datos, cada columna es un vector. Aquí aprendemos más sobre esta importante clase.

### Crear vectores

Podemos crear vectores usando la función `c`, que significa _concatenate_. Usamos `c` para concatenar entradas de la siguiente manera:

```{r}
codes <- c(380, 124, 818)
codes
```

También podemos crear vectores de caracteres. Usamos las comillas para denotar que las entradas son caracteres en lugar de nombres de variables.

```{r}
country <- c("italy", "canada", "egypt")
```

En R también puedes usar comillas simples:

```{r}
country <- c('italy', 'canada', 'egypt')
```

Pero tenga cuidado de no confundir la comilla simple &#39;con la _back quote_&#39;.

A estas alturas ya debería saber que si escribe:

```{r, eval=FALSE}
country <- c(italy, canada, egypt)
```
recibes un error porque las variables `italy`, `canada` y `egypt` no están definidos. Si no usamos las comillas, R busca variables con esos nombres y devuelve un error.

### Nombres

A veces es útil nombrar las entradas de un vector. Por ejemplo, al definir un vector de códigos de país, podemos usar los nombres para conectar los dos:

```{r}
codes <- c(italy = 380, canada = 124, egypt = 818)
codes
```

El objeto `codes` sigue siendo un vector numérico:
```{r}
class(codes)
```
pero con nombres:
```{r}
names(codes)
```

Si el uso de cadenas sin comillas parece confuso, sepa que también puede usar las comillas:

```{r}
codes <- c("italy" = 380, "canada" = 124, "egypt" = 818)
codes
```

No hay diferencia entre esta llamada de función y la anterior. Esta es una de las muchas formas en que R es peculiar en comparación con otros lenguajes.

También podemos asignar nombres usando el `names` funciones:

```{r}
codes <- c(380, 124, 818)
country <- c("italy","canada","egypt")
names(codes) <- country
codes
```

### Secuencias

Otra función útil para crear vectores genera secuencias:

```{r}
seq(1, 10)
```

El primer argumento define el inicio, y el segundo define el final que se incluye. El valor predeterminado es subir en incrementos de 1, pero un tercer argumento nos permite decir cuánto saltar:

```{r}
seq(1, 10, 2)
```

Si queremos enteros consecutivos, podemos usar la siguiente taquigrafía:

```{r}
1:10
```

Cuando usamos estas funciones, R produce números enteros, no numéricos, porque generalmente se usan para indexar algo:

```{r}
class(1:10)
```

Sin embargo, si creamos una secuencia que incluye no enteros, la clase cambia:

```{r}
class(seq(1, 10, 0.5))
```

### Subconjunto

Usamos corchetes para acceder a elementos específicos de un vector. Para el vector `codes` que definimos anteriormente, podemos acceder al segundo elemento usando:
```{r}
codes[2]
```

Puede obtener más de una entrada utilizando un vector de entradas múltiples como índice:
```{r}
codes[c(1,3)]
```

Las secuencias definidas anteriormente son particularmente útiles si queremos acceder, digamos, a los dos primeros elementos:

```{r}
codes[1:2]
```

Si los elementos tienen nombres, también podemos acceder a las entradas utilizando estos nombres. A continuación hay dos ejemplos.

```{r}
codes["canada"]
codes[c("egypt","italy")]
```

## Coerción

En general, _coercion_ es un intento de R de ser flexible con los tipos de datos. Cuando una entrada no coincide con lo esperado, algunas de las funciones R preconstruidas intentan adivinar lo que significaba antes de arrojar un error. Esto también puede conducir a la confusión. Si no se comprende la _coerción_, los programadores pueden volverse locos al intentar codificar en R, ya que se comporta de manera bastante diferente a la mayoría de los otros idiomas a este respecto. Aprendamos sobre esto con algunos ejemplos.

Dijimos que los vectores deben ser todos del mismo tipo. Entonces, si tratamos de combinar, digamos, números y caracteres, puede esperar un error:

```{r}
x <- c(1, "canada", 3)
```

¡Pero no tenemos uno, ni siquiera una advertencia! ¿Que pasó? Mirar `x` y su clase:

```{r}
x
class(x)
```

R _coerció_ los datos en caracteres. Supuso que debido a que pones una cadena de caracteres en el vector, querías decir que el 1 y el 3 en realidad son cadenas de caracteres `"1"` y " `3`&Quot;. El hecho de que ni siquiera se emita una advertencia es un ejemplo de cómo la coerción puede causar muchos errores inadvertidos en R.

R también ofrece funciones para cambiar de un tipo a otro. Por ejemplo, puede convertir números en caracteres con:

```{r}
x <- 1:5
y <- as.character(x)
y
```

Puedes devolverlo con `as.numeric`:

```{r}
as.numeric(y)
```

Esta función es realmente bastante útil ya que los conjuntos de datos que incluyen números como cadenas de caracteres son comunes.

### No disponible (NA)

Cuando una función intenta forzar un tipo a otro y encuentra un caso imposible, generalmente nos da una advertencia y convierte la entrada en un valor especial llamado `NA` para "no disponible". Por ejemplo:

```{r}
x <- c("1", "b", "3")
as.numeric(x)
```

R no tiene ninguna conjetura sobre el número que desea cuando escribe `b`, por lo que no lo intenta.

Como científico de datos, se encontrará con el `NA` a menudo, como se usan generalmente para datos faltantes, un problema común en los conjuntos de datos del mundo real.

## Ejercicios

1\. Usa la función `c` para crear un vector con las temperaturas altas promedio en enero para Beijing, Lagos, París, Río de Janeiro, San Juan y Toronto, que son 35, 88, 42, 84, 81 y 30 grados Fahrenheit. Llamar al objeto `temp`.

2\. Ahora crea un vector con los nombres de las ciudades y llama al objeto `city`.


3\. Utilizar el `names` función y los objetos definidos en los ejercicios anteriores para asociar los datos de temperatura con su ciudad correspondiente.


4\. Utilizar el `[` y `:` operadores para acceder a la temperatura de las tres primeras ciudades de la lista.


5\. Utilizar el `[` operador para acceder a la temperatura de París y San Juan.

6\. Utilizar el `:` operador para crear una secuencia de números $12,13,14,\dots,73$.

7\. Cree un vector que contenga todos los números impares positivos menores que 100.

8\. Cree un vector de números que comience en 6, no pase 55 y agregue números en incrementos de 4/7: 6, 6 + 4/7, 6 + 8/7, y así sucesivamente. ¿Cuántos números tiene la lista? Sugerencia: uso `seq` y `length`.

9\. ¿Cuál es la clase del siguiente objeto? `a <- seq(1, 10, 0.5)`?



10\. ¿Cuál es la clase del siguiente objeto? `a <- seq(1, 10)`?


11\. La clase de `class(a<-1)` es numérico, no entero. R por defecto es numérico y para forzar un número entero, debe agregar la letra `L`. Confirme que la clase de `1L` es entero


12\. Defina el siguiente vector:

```{r}
x <- c("1", "3", "5")
```

y obligarlo a obtener enteros.




##Clasificación

Ahora que hemos dominado algunos conocimientos básicos de R, intentemos obtener algunos conocimientos sobre la seguridad de los diferentes estados en el contexto de los asesinatos con armas de fuego.

### `sort`

Digamos que queremos clasificar los estados desde el menor hasta la mayoría de los asesinatos con armas de fuego. La función `sort` ordena un vector en orden creciente. Por lo tanto, podemos ver la mayor cantidad de asesinatos de armas escribiendo:

```{r}
library(dslabs)
data(murders)
sort(murders$total)
```

Sin embargo, esto no nos da información sobre qué estados tienen qué asesinatos totales. Por ejemplo, no sabemos qué estado tenía `r max(murders$total)`.

### `order`

La función `order` está más cerca de lo que queremos Toma un vector como entrada y devuelve el vector de índices que clasifica el vector de entrada. Esto puede sonar confuso, así que veamos un ejemplo simple. Podemos crear un vector y ordenarlo:

```{r}
x <- c(31, 4, 15, 92, 65)
sort(x)
```

En lugar de ordenar el vector de entrada, la función `order` devuelve el índice que ordena el vector de entrada:

```{r}
index <- order(x)
x[index]
```

Este es el mismo resultado que el devuelto por `sort(x)`. Si miramos este índice, vemos por qué funciona:
```{r}
x
order(x)
```

La segunda entrada de `x` es el más pequeño, entonces `order(x)` comienza con `2`. La siguiente más pequeña es la tercera entrada, por lo que la segunda entrada es `3` y así.

¿Cómo nos ayuda esto a ordenar los estados por asesinatos? Primero, recuerde que las entradas de vectores a las que accede `$` siga el mismo orden que las filas de la tabla. Por ejemplo, estos dos vectores que contienen nombres de estado y abreviaturas, respectivamente, se corresponden por su orden:

```{r}
murders$state[1:6]
murders$abb[1:6]
```

Esto significa que podemos ordenar los nombres de estado por sus asesinatos totales. Primero obtenemos el índice que ordena los vectores según los totales de asesinatos y luego indexamos el vector de nombres de estado:

```{r}
ind <- order(murders$total)
murders$abb[ind]
```

Según lo anterior, California tuvo la mayor cantidad de asesinatos.

### `max` y `which.max`

Si solo estamos interesados en la entrada con el mayor valor, podemos usar `max` por el valor:

```{r}
max(murders$total)
```

y `which.max` para el índice del mayor valor:

```{r}
i_max <- which.max(murders$total)
murders$state[i_max]
```

Como mínimo, podemos usar `min` y `which.min` del mismo modo.

¿Significa esto que California es el estado más peligroso? En una próxima sección, argumentamos que deberíamos considerar las tasas en lugar de los totales. Antes de hacer eso, presentamos una última función relacionada con el orden: `rank`.

### `rank`

Aunque no se usa con tanta frecuencia como `order` y `sort`, la función `rank` también está relacionado con el orden y puede ser útil.
Para cualquier vector dado, devuelve un vector con el rango de la primera entrada, segunda entrada, etc., del vector de entrada. Aquí hay un ejemplo simple:

```{r}
x <- c(31, 4, 15, 92, 65)
rank(x)
```

Para resumir, veamos los resultados de las tres funciones que hemos introducido:

```{r, echo=FALSE}
tmp <- data.frame(original=x, sort=sort(x), order=order(x), rank=rank(x))
if(knitr::is_html_output()){
knitr::kable(tmp, "html") %>%
kableExtra::kable_styling(bootstrap_options = "striped", full_width = FALSE)
} else{
knitr::kable(tmp, "latex", booktabs = TRUE) %>%
kableExtra::kable_styling(font_size = 8)
}
```


### Cuidado con el reciclaje

Otra fuente común de errores inadvertidos en R es el uso de _recycling_. Vimos que los vectores se agregan por elementos. Entonces, si los vectores no coinciden en longitud, es natural suponer que deberíamos obtener un error. Pero nosotros no. Note lo que pasa:

```{r, warning=TRUE}
x <- c(1,2,3)
y <- c(10, 20, 30, 40, 50, 60, 70)
x+y
```
Recibimos una advertencia, pero no hay error. Para la salida, R ha reciclado los números en `x`. Observe el último dígito de números en la salida.


## Ejercicios

Para estos ejercicios usaremos el conjunto de datos de asesinatos de Estados Unidos. Asegúrese de cargarlo antes de comenzar.

```{r}
library(dslabs)
data("murders")
```

1\. Utilizar el `$` operador para acceder a los datos del tamaño de la población y almacenarlos como el objeto `pop`. Luego usa el `sort` función para redefinir `pop` para que esté ordenado Finalmente, usa el `[` operador para informar el tamaño de población más pequeño.

2\. Ahora, en lugar del tamaño de población más pequeño, encuentre el índice de la entrada con el tamaño de población más pequeño. Sugerencia: uso `order` en lugar de `sort`.

3\. Realmente podemos realizar la misma operación que en el ejercicio anterior usando la función `which.min`. Escribe una línea de código que haga esto.

4\. Ahora sabemos cuán pequeño es el estado más pequeño y sabemos qué fila lo representa. Que estado es Definir una variable. `states` ser los nombres de estado de la `murders` marco de datos. Informe el nombre del estado con la población más pequeña.

5\. Puede crear un marco de datos utilizando el `data.frame` función. Aquí hay un ejemplo rápido:


```{r}
temp <- c(35, 88, 42, 84, 81, 30)
city <- c("Beijing", "Lagos", "Paris", "Rio de Janeiro",
"San Juan", "Toronto")
city_temps <- data.frame(name = city, temperature = temp)
```

Utilizar el `rank` función para determinar el rango de población de cada estado desde el tamaño de población más pequeño hasta el más grande. Guarde estos rangos en un objeto llamado `ranks`, luego cree un marco de datos con el nombre del estado y su rango. Llamar al marco de datos `my_df`.

6\. Repita el ejercicio anterior, pero esta vez ordene `my_df` para que los estados se ordenen de menos poblados a más poblados. Sugerencia: crea un objeto `ind` que almacena los índices necesarios para ordenar los valores de la población. Luego use el operador de soporte `[` para reordenar cada columna en el marco de datos.

7\. Los `na_example` el vector representa una serie de recuentos. Puede examinar rápidamente el objeto usando:

```{r}
data("na_example")
str(na_example)
```

Sin embargo, cuando calculamos el promedio con la función `mean`, obtenemos un `NA`:

```{r}
mean(na_example)
```

Los `is.na` la función devuelve un vector lógico que nos dice qué entradas son `NA`. Asigne este vector lógico a un objeto llamado `ind` y determina cuantos `NA` s hace `na_example` tener.


8\. Ahora calcule el promedio nuevamente, pero solo para las entradas que no son `NA`. Pista: recuerda el `!` operador.



## Aritmética de vectores

California tuvo la mayor cantidad de asesinatos, pero ¿esto significa que es el estado más peligroso? ¿Qué pasa si solo tiene muchas más personas que cualquier otro estado? Podemos confirmar rápidamente que California tiene la mayor población:

```{r}
library(dslabs)
data("murders")
murders$state[which.max(murders$population)]
```

con más de `r floor(max(murders$population)/10^6)` millones de habitantes Por lo tanto, es injusto comparar los totales si estamos interesados en saber qué tan seguro es el estado. Lo que realmente deberíamos calcular son los asesinatos per cápita. Los informes que describimos en la sección motivadora utilizaron asesinatos por cada 100,000 como la unidad. Para calcular esta cantidad, las poderosas capacidades aritméticas de vectores de R son útiles.

### Reescalando un vector

En R, las operaciones aritméticas en vectores ocurren _elemento-sabio_. Para un ejemplo rápido, supongamos que tenemos la altura en pulgadas:

```{r}
inches <- c(69, 62, 66, 70, 70, 73, 67, 73, 67, 70)
```
y quiero convertir a centímetros. Note lo que sucede cuando multiplicamos `inches` por 2.54:

```{r}
inches * 2.54
```

En la línea de arriba, multiplicamos cada elemento por 2.54. Del mismo modo, si para cada entrada queremos calcular cuántas pulgadas más alto o más corto que 69 pulgadas, la altura promedio para los hombres, podemos restarlo de cada entrada de esta manera:

```{r}
inches - 69
```


### Dos vectores

Si tenemos dos vectores de la misma longitud y los sumamos en R, se agregarán entrada por entrada de la siguiente manera:

$$
\begin{pmatrix}
a\\
b\\
c\\
d
\end{pmatrix}
+
\begin{pmatrix}
e\\
f\\
g\\
h
\end{pmatrix}
=
\begin{pmatrix}
a +e\\
b + f\\
c + g\\
d + h
\end{pmatrix}
$$

Lo mismo vale para otras operaciones matemáticas, como `-`, `*` y `/`.

Esto implica que para calcular las tasas de asesinatos simplemente podemos escribir:

```{r}
murder_rate <- murders$total/ murders$population * 100000
```

Una vez que hacemos esto, notamos que California ya no está cerca de la parte superior de la lista. De hecho, podemos usar lo que hemos aprendido para ordenar a los estados por tasa de asesinatos:

```{r}
murders$abb[order(murder_rate)]
```


## Ejercicios

1\. Anteriormente creamos este marco de datos:

```{r}
temp <- c(35, 88, 42, 84, 81, 30)
city <- c("Beijing", "Lagos", "Paris", "Rio de Janeiro",
"San Juan", "Toronto")
city_temps <- data.frame(name = city, temperature = temp)
```

Vuelva a crear el marco de datos utilizando el código anterior, pero agregue una línea que convierta la temperatura de Fahrenheit a Celsius. La conversión es $C = \frac{5}{9} \times (F - 32)$.

2\. ¿Cuál es la siguiente suma? $1+1/2^2 + 1/3^2 + \dots 1/100^2$? Sugerencia: gracias a Euler, sabemos que debería estar cerca de $\pi^2/6$.

3\. Calcule la tasa de asesinatos por cada 100,000 para cada estado y almacénela en el objeto `murder_rate`. Luego calcule la tasa promedio de asesinatos para los EE. UU. Con la función `mean`. ¿Cuál es el promedio?

## Indexación

R proporciona una forma poderosa y conveniente de indexar vectores. Podemos, por ejemplo, subconjuntar un vector en función de las propiedades de otro vector. En esta sección, continuamos trabajando con nuestro ejemplo de asesinatos en EE. UU., Que podemos cargar así:

```{r}
library(dslabs)
data("murders")
```

### Subconjunto con lógicas

Ahora hemos calculado la tasa de asesinatos usando:

```{r}
murder_rate <- murders$total/ murders$population * 100000
```

Imagine que se muda de Italia donde, según un informe de noticias de ABC, la tasa de asesinatos es de solo 0.71 por 100,000. Preferiría mudarse a un estado con una tasa de homicidios similar. Otra característica poderosa de R es que podemos usar lógicas para indexar vectores. Si comparamos un vector con un solo número, en realidad realiza la prueba para cada entrada. El siguiente es un ejemplo relacionado con la pregunta anterior:

```{r}
ind <- murder_rate < 0.71
```

Si en cambio queremos saber si un valor es menor o igual, podemos usar:

```{r}
ind <- murder_rate <= 0.71
```

Tenga en cuenta que recuperamos un vector lógico con `TRUE` para cada entrada menor o igual a 0.71. Para ver qué estados son estos, podemos aprovechar el hecho de que los vectores pueden indexarse con lógicos.

```{r}
murders$state[ind]
```

Para contar cuántos son VERDADEROS, la función `sum` devuelve la suma de las entradas de un vector y los vectores lógicos se _coerced_ a numéricos con `TRUE` codificado como 1 y `FALSE` como 0. Así podemos contar los estados usando:

```{r}
sum(ind)
```


### Operadores logicos

Supongamos que nos gustan las montañas y queremos mudarnos a un estado seguro en la región occidental del país. Queremos que la tasa de asesinatos sea como máximo 1. En este caso, queremos que dos cosas diferentes sean ciertas. Aquí podemos usar el operador lógico _y_, que en R se representa con `&`. Esta operación da como resultado `TRUE` solo cuando ambas lógicas son `TRUE`. Para ver esto, considere este ejemplo:

```{r}
TRUE & TRUE
TRUE & FALSE
FALSE & FALSE
```

Para nuestro ejemplo, podemos formar dos lógicas:

```{r}
west <- murders$region == "West"
safe <- murder_rate <= 1
```

y podemos usar el `&` para obtener un vector de lógicas que nos dice qué estados satisfacen ambas condiciones:

```{r}
ind <- safe & west
murders$state[ind]
```

### `which`

Supongamos que queremos ver la tasa de asesinatos de California. Para este tipo de operación, es conveniente convertir vectores de lógicos en índices en lugar de mantener largos vectores de lógicos. La función `which` nos dice qué entradas de un vector lógico son VERDADERAS. Entonces podemos escribir:

```{r}
ind <- which(murders$state == "California")
murder_rate[ind]
```


### `match`

Si en lugar de un solo estado queremos averiguar las tasas de homicidio de varios estados, digamos Nueva York, Florida y Texas, podemos usar la función `match`. Esta función nos dice qué índices de un segundo vector coinciden con cada una de las entradas de un primer vector:

```{r}
ind <- match(c("New York", "Florida", "Texas"), murders$state)
ind
```

Ahora podemos ver las tasas de asesinatos:

```{r}
murder_rate[ind]
```

### `%in%`


Si en lugar de un índice queremos una lógica que nos diga si cada elemento de un primer vector está en un segundo, podemos usar la función `%in%`. Imaginemos que no está seguro de si Boston, Dakota y Washington son estados. Puedes averiguar así:

```{r}
c("Boston", "Dakota", "Washington") %in% murders$state
```

Tenga en cuenta que estaremos usando `%in%` a menudo a lo largo del libro.

**Avanzado**: hay una conexión entre `match` y `%in%` mediante `which`. Para ver esto, observe que las siguientes dos líneas producen el mismo índice (aunque en diferente orden):

```{r}
match(c("New York", "Florida", "Texas"), murders$state)
which(murders$state%in%c("New York", "Florida", "Texas"))
```

## Ejercicios

Comience cargando la biblioteca y los datos.
```{r}
library(dslabs)
data(murders)
```

1\. Calcule la tasa de asesinatos por cada 100,000 para cada estado y almacénela en un objeto llamado `murder_rate`. Luego use operadores lógicos para crear un vector lógico llamado `low` eso nos dice qué entradas de `murder_rate` son inferiores a 1.

2\. Ahora use los resultados del ejercicio anterior y la función `which` para determinar los índices de `murder_rate` asociado con valores inferiores a 1.

3\. Use los resultados del ejercicio anterior para informar los nombres de los estados con tasas de asesinatos inferiores a 1.

4\. Ahora extienda el código de los ejercicios 2 y 3 para informar los estados del noreste con tasas de homicidios inferiores a 1. Sugerencia: use el vector lógico previamente definido `low` y el operador lógico `&`.

5\. En un ejercicio anterior, calculamos la tasa de homicidios para cada estado y el promedio de estos números. ¿Cuántos estados están por debajo del promedio?

6\. Use la función de coincidencia para identificar los estados con abreviaturas AK, MI e IA. Sugerencia: comience definiendo un índice de las entradas de `murders$abb` que coinciden con las tres abreviaturas, luego use el `[` operador para extraer los estados.

7\. Utilizar el `%in%` operador para crear un vector lógico que responda a la pregunta: ¿cuáles de las siguientes son abreviaturas reales: MA, ME, MI, MO, MU?

8\. Extienda el código que usó en el ejercicio 7 para informar la entrada que no es **no** una abreviatura real. Sugerencia: use el `!` operador, que gira `FALSE` dentro `TRUE` y viceversa, entonces `which` para obtener un índice.

## Parcelas básicas

En el capitulo \@ref(ggplot2) describimos un paquete complementario que proporciona un enfoque poderoso para producir gráficos en R. Luego tenemos una parte completa sobre la visualización de datos en la que proporcionamos muchos ejemplos. Aquí describimos brevemente algunas de las funciones que están disponibles en una instalación básica de R.

### `plot`

Los `plot` la función se puede utilizar para hacer diagramas de dispersión. Aquí hay una trama de asesinatos totales versus población.

```{r eval=FALSE}
x <- murders$population/ 10^6
y <- murders$total
plot(x, y)
```


```{r first-plot, out.width="60%", echo=FALSE}
rafalib::mypar()
x <- murders$population/ 10^6
y <- murders$total
plot(x, y)
```

Para una trama rápida que evita el acceso a las variables dos veces, podemos usar el `with` función:

```{r, eval=FALSE}
with(murders, plot(population, total))
```

La función `with` vamos a usar el `murders` nombres de columna en el `plot` función. También funciona con cualquier marco de datos y cualquier función.

### `hist`

Describiremos los histogramas en relación con las distribuciones en la parte de visualización de datos del libro. Aquí simplemente notaremos que los histogramas son un poderoso resumen gráfico de una lista de números que le brinda una visión general de los tipos de valores que tiene. Podemos hacer un histograma de nuestras tasas de asesinatos simplemente escribiendo:

```{r eval=FALSE}
x <- with(murders, total/ population * 100000)
hist(x)
```

```{r r-base-hist, out.width="60%",echo=FALSE}
rafalib::mypar()
x <- with(murders, total/ population * 100000)
hist(x)
```

Podemos ver que hay una amplia gama de valores con la mayoría de ellos entre 2 y 3 y un caso muy extremo con una tasa de asesinatos de más de 15:

```{r}
murders$state[which.max(x)]
```

### `boxplot`

Los diagramas de caja también se describirán en la parte de visualización de datos del libro. Proporcionan un resumen más conciso que los histogramas, pero son más fáciles de apilar con otros diagramas de caja. Por ejemplo, aquí podemos usarlos para comparar las diferentes regiones:

```{r eval=FALSE}
murders$rate <- with(murders, total/ population * 100000)
boxplot(rate~region, data = murders)
```

```{r r-base-boxplot, out.width="60%", echo=FALSE}
rafalib::mypar()
murders$rate <- with(murders, total/ population * 100000)
boxplot(rate~region, data = murders)
```

Podemos ver que el Sur tiene tasas de asesinatos más altas que las otras tres regiones.

### `image`

La función de imagen muestra los valores en una matriz usando color. Aquí hay un ejemplo rápido:

```{r eval=FALSE}
x <- matrix(1:120, 12, 10)
image(x)
```

```{r image-first-example, fig.height=4, fig.width=4, echo=FALSE, out.width="50%"}
rafalib::mypar()
x <- matrix(1:120, 12, 10)
image(x)
```


## Ejercicios

1\. Hicimos una trama de asesinatos totales versus población y notamos una fuerte relación. No es sorprendente que los estados con poblaciones más grandes hayan tenido más asesinatos.

```{r, eval = FALSE}
library(dslabs)
data(murders)
population_in_millions <- murders$population/10^6
total_gun_murders <- murders$total
plot(population_in_millions, total_gun_murders)
```

Tenga en cuenta que muchos estados tienen poblaciones inferiores a 5 millones y están agrupados. Podemos obtener más información al hacer este diagrama en la escala logarítmica. Transforme las variables usando el `log10` transformación y luego trazarlos.


2\. Crea un histograma de las poblaciones estatales.


3\. Generar diagramas de caja de las poblaciones estatales por región.




